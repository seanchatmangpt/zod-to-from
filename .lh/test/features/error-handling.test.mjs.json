{
    "sourceFile": "test/features/error-handling.test.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758645130119,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758645130119,
            "name": "Commit-0",
            "content": "/**\n * Error Handling Tests\n * @fileoverview Comprehensive tests for error handling and validation\n */\n\nimport { beforeEach, describe, expect, it } from 'vitest';\nimport { z } from 'zod';\nimport { convert, formatTo, parseFrom } from '../../src/core/main.mjs';\n\ndescribe('Error Handling', () => {\n  const SimpleSchema = z.object({\n    name: z.string(),\n    age: z.number(),\n    active: z.boolean(),\n  });\n\n  const ComplexSchema = z.object({\n    id: z.string().uuid(),\n    metadata: z.object({\n      tags: z.array(z.string()),\n      score: z.number().min(0).max(100),\n    }),\n    nested: z.object({\n      value: z.string(),\n      optional: z.string().optional(),\n    }),\n  });\n\n  beforeEach(() => {\n    // Ensure clean state for each test\n  });\n\n  describe('Parse Errors', () => {\n    it('should throw error for unknown format', async () => {\n      const input = '{\"name\": \"Test\"}';\n\n      await expect(parseFrom(SimpleSchema, 'unknown-format', input)).rejects.toThrow(\n        'No adapter found for format: unknown-format'\n      );\n    });\n\n    it('should throw error for malformed JSON', async () => {\n      const malformedJSON = '{\"name\": \"Test\", \"age\": 30, \"active\": true'; // Missing closing brace\n\n      await expect(parseFrom(SimpleSchema, 'json', malformedJSON)).rejects.toThrow();\n    });\n\n    it('should throw error for malformed CSV', async () => {\n      const malformedCSV = `name,age,active\nJohn,30,true\nJane,25`; // Missing active column\n\n      await expect(parseFrom(SimpleSchema, 'csv', malformedCSV)).rejects.toThrow();\n    });\n\n    it('should throw error for malformed NDJSON', async () => {\n      const malformedNDJSON = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n{\"name\": \"Jane\", \"age\": 25, \"active\": false,}`; // Trailing comma\n\n      await expect(parseFrom(SimpleSchema, 'ndjson', malformedNDJSON)).rejects.toThrow();\n    });\n\n    it('should throw error for empty input', async () => {\n      await expect(parseFrom(SimpleSchema, 'json', '')).rejects.toThrow();\n    });\n\n    it('should throw error for null input', async () => {\n      await expect(parseFrom(SimpleSchema, 'json', undefined)).rejects.toThrow();\n    });\n\n    it('should throw error for undefined input', async () => {\n      await expect(parseFrom(SimpleSchema, 'json', undefined)).rejects.toThrow();\n    });\n  });\n\n  describe('Schema Validation Errors', () => {\n    it('should throw error for invalid data types', async () => {\n      const invalidData = { name: 'Test', age: 'not-a-number', active: true };\n\n      await expect(formatTo(SimpleSchema, 'json', invalidData)).rejects.toThrow();\n    });\n\n    it('should throw error for missing required fields', async () => {\n      const incompleteData = { name: 'Test' }; // Missing age and active\n\n      await expect(formatTo(SimpleSchema, 'json', incompleteData)).rejects.toThrow();\n    });\n\n    it('should throw error for extra fields when strict', async () => {\n      const extraData = { name: 'Test', age: 30, active: true, extra: 'field' };\n\n      await expect(formatTo(SimpleSchema, 'json', extraData)).rejects.toThrow();\n    });\n\n    it('should throw error for invalid UUID', async () => {\n      const invalidUUID = {\n        id: 'not-a-uuid',\n        metadata: {\n          tags: ['test'],\n          score: 50,\n        },\n        nested: {\n          value: 'test',\n        },\n      };\n\n      await expect(formatTo(ComplexSchema, 'json', invalidUUID)).rejects.toThrow();\n    });\n\n    it('should throw error for score out of range', async () => {\n      const invalidScore = {\n        id: '123e4567-e89b-12d3-a456-426614174000',\n        metadata: {\n          tags: ['test'],\n          score: 150, // Out of range (0-100)\n        },\n        nested: {\n          value: 'test',\n        },\n      };\n\n      await expect(formatTo(ComplexSchema, 'json', invalidScore)).rejects.toThrow();\n    });\n\n    it('should throw error for negative score', async () => {\n      const negativeScore = {\n        id: '123e4567-e89b-12d3-a456-426614174000',\n        metadata: {\n          tags: ['test'],\n          score: -10, // Negative score\n        },\n        nested: {\n          value: 'test',\n        },\n      };\n\n      await expect(formatTo(ComplexSchema, 'json', negativeScore)).rejects.toThrow();\n    });\n  });\n\n  describe('Format Errors', () => {\n    it('should throw error for unknown format', async () => {\n      const data = { name: 'Test', age: 30, active: true };\n\n      await expect(formatTo(SimpleSchema, 'unknown-format', data)).rejects.toThrow(\n        'No adapter found for format: unknown-format'\n      );\n    });\n\n    it('should throw error for null data', async () => {\n      await expect(formatTo(SimpleSchema, 'json', undefined)).rejects.toThrow();\n    });\n\n    it('should throw error for undefined data', async () => {\n      await expect(formatTo(SimpleSchema, 'json', undefined)).rejects.toThrow();\n    });\n\n    it('should throw error for circular references', async () => {\n      const circularData = { name: 'Test', age: 30, active: true };\n      circularData.self = circularData; // Create circular reference\n\n      await expect(formatTo(SimpleSchema, 'json', circularData)).rejects.toThrow();\n    });\n  });\n\n  describe('Conversion Errors', () => {\n    it('should throw error for unknown source format', async () => {\n      const input = '{\"name\": \"Test\"}';\n\n      await expect(convert(SimpleSchema, { from: 'unknown', to: 'json' }, input)).rejects.toThrow(\n        'No adapter found for format: unknown'\n      );\n    });\n\n    it('should throw error for unknown target format', async () => {\n      const input = '{\"name\": \"Test\"}';\n\n      await expect(convert(SimpleSchema, { from: 'json', to: 'unknown' }, input)).rejects.toThrow(\n        'No adapter found for format: unknown'\n      );\n    });\n\n    it('should throw error for malformed input during conversion', async () => {\n      const malformedInput = '{\"name\": \"Test\", \"age\": 30, \"active\": true'; // Missing closing brace\n\n      await expect(\n        convert(SimpleSchema, { from: 'json', to: 'json' }, malformedInput)\n      ).rejects.toThrow();\n    });\n\n    it('should throw error for schema validation during conversion', async () => {\n      const invalidInput = '{\"name\": \"Test\", \"age\": \"not-a-number\", \"active\": true}';\n\n      await expect(\n        convert(SimpleSchema, { from: 'json', to: 'json' }, invalidInput)\n      ).rejects.toThrow();\n    });\n  });\n\n  describe('Streaming Errors', () => {\n    it('should throw error for streaming on non-streaming adapters', async () => {\n      const input = '{\"name\": \"Test\", \"age\": 30, \"active\": true}';\n\n      await expect(parseFrom(SimpleSchema, 'json', input, { streaming: true })).rejects.toThrow(\n        \"Adapter 'json' does not support streaming\"\n      );\n    });\n\n    it('should throw error for streaming format on non-streaming adapters', async () => {\n      const data = { name: 'Test', age: 30, active: true };\n\n      await expect(formatTo(SimpleSchema, 'json', data, { streaming: true })).rejects.toThrow(\n        \"Adapter 'json' does not support streaming\"\n      );\n    });\n\n    it('should handle streaming errors gracefully', async () => {\n      const malformedCSV = `name,age,active\nJohn,30,true\nJane,25`; // Missing active column\n\n      await expect(\n        parseFrom(SimpleSchema, 'csv', malformedCSV, { streaming: true })\n      ).rejects.toThrow();\n    });\n  });\n\n  describe('Adversarial Input Testing', () => {\n    it('should handle very large inputs', async () => {\n      const largeData = {\n        name: 'A'.repeat(1_000_000), // 1MB string\n        age: 30,\n        active: true,\n      };\n\n      // Should either succeed or fail gracefully\n      try {\n        const result = await formatTo(SimpleSchema, 'json', largeData);\n        expect(result).toBeDefined();\n      } catch (error) {\n        expect(error).toBeDefined();\n        expect(error.message).toBeDefined();\n      }\n    });\n\n    it('should handle deeply nested objects', async () => {\n      let deepObject = { name: 'Test', age: 30, active: true };\n      let current = deepObject;\n\n      // Create deeply nested object\n      for (let i = 0; i < 1000; i++) {\n        current.nested = { level: i };\n        current = current.nested;\n      }\n\n      // Should either succeed or fail gracefully\n      try {\n        const result = await formatTo(SimpleSchema, 'json', deepObject);\n        expect(result).toBeDefined();\n      } catch (error) {\n        expect(error).toBeDefined();\n        expect(error.message).toBeDefined();\n      }\n    });\n\n    it('should handle special characters in input', async () => {\n      const specialChars = {\n        name: 'Test with special chars: \\n\\r\\t\"\\'\\\\',\n        age: 30,\n        active: true,\n      };\n\n      const result = await formatTo(SimpleSchema, 'json', specialChars);\n      expect(result).toBeDefined();\n    });\n\n    it('should handle unicode characters', async () => {\n      const unicodeData = {\n        name: 'JosÃ© FranÃ§ois ä¸­æ–‡ ðŸš€',\n        age: 30,\n        active: true,\n      };\n\n      const result = await formatTo(SimpleSchema, 'json', unicodeData);\n      expect(result).toBeDefined();\n    });\n  });\n\n  describe('Error Message Quality', () => {\n    it('should provide descriptive error messages for schema validation', async () => {\n      const invalidData = { name: 'Test', age: 'not-a-number', active: true };\n\n      try {\n        await formatTo(SimpleSchema, 'json', invalidData);\n        expect.fail('Should have thrown an error');\n      } catch (error) {\n        expect(error.message).toContain('age');\n        expect(error.message).toContain('number');\n      }\n    });\n\n    it('should provide descriptive error messages for missing fields', async () => {\n      const incompleteData = { name: 'Test' }; // Missing age and active\n\n      try {\n        await formatTo(SimpleSchema, 'json', incompleteData);\n        expect.fail('Should have thrown an error');\n      } catch (error) {\n        expect(error.message).toContain('age');\n        expect(error.message).toContain('active');\n      }\n    });\n\n    it('should provide descriptive error messages for format errors', async () => {\n      const malformedJSON = '{\"name\": \"Test\", \"age\": 30, \"active\": true'; // Missing closing brace\n\n      try {\n        await parseFrom(SimpleSchema, 'json', malformedJSON);\n        expect.fail('Should have thrown an error');\n      } catch (error) {\n        expect(error.message).toBeDefined();\n        expect(error.message.length).toBeGreaterThan(0);\n      }\n    });\n  });\n\n  describe('Error Recovery', () => {\n    it('should handle partial failures gracefully', async () => {\n      const malformedCSV = `name,age,active\nJohn,30,true\nJane,25,false\nInvalid,not-a-number,true`;\n\n      try {\n        await parseFrom(SimpleSchema, 'csv', malformedCSV);\n        expect.fail('Should have thrown an error');\n      } catch (error) {\n        expect(error).toBeDefined();\n        expect(error.message).toBeDefined();\n      }\n    });\n\n    it('should handle network-like errors gracefully', async () => {\n      // Simulate network-like errors by providing malformed input\n      const networkErrorInput = '{\"name\": \"Test\", \"age\": 30, \"active\": true}';\n\n      try {\n        const result = await parseFrom(SimpleSchema, 'json', networkErrorInput);\n        expect(result).toBeDefined();\n      } catch (error) {\n        expect(error).toBeDefined();\n        expect(error.message).toBeDefined();\n      }\n    });\n  });\n\n  describe('Error Types', () => {\n    it('should throw appropriate error types', async () => {\n      // Test for different error types\n      const testCases = [\n        {\n          input: '{\"name\": \"Test\", \"age\": \"not-a-number\", \"active\": true}',\n          format: 'json',\n          expectedErrorType: 'ZodError',\n        },\n        {\n          input: '{\"name\": \"Test\", \"age\": 30, \"active\": true',\n          format: 'json',\n          expectedErrorType: 'SyntaxError',\n        },\n        {\n          input: '{\"name\": \"Test\"}',\n          format: 'unknown-format',\n          expectedErrorType: 'Error',\n        },\n      ];\n\n      for (const testCase of testCases) {\n        try {\n          await parseFrom(SimpleSchema, testCase.format, testCase.input);\n          expect.fail(`Should have thrown an error for ${testCase.format}`);\n        } catch (error) {\n          expect(error).toBeDefined();\n          expect(error.constructor.name).toBeDefined();\n        }\n      }\n    });\n  });\n\n  describe('Error Context Preservation', () => {\n    it('should preserve error context through conversion', async () => {\n      const malformedInput = '{\"name\": \"Test\", \"age\": 30, \"active\": true'; // Missing closing brace\n\n      try {\n        await convert(SimpleSchema, { from: 'json', to: 'json' }, malformedInput);\n        expect.fail('Should have thrown an error');\n      } catch (error) {\n        expect(error).toBeDefined();\n        expect(error.message).toBeDefined();\n        // Error should contain context about the parsing step\n      }\n    });\n\n    it('should preserve error context through streaming', async () => {\n      const malformedCSV = `name,age,active\nJohn,30,true\nJane,25`; // Missing active column\n\n      try {\n        await parseFrom(SimpleSchema, 'csv', malformedCSV, { streaming: true });\n        expect.fail('Should have thrown an error');\n      } catch (error) {\n        expect(error).toBeDefined();\n        expect(error.message).toBeDefined();\n        // Error should contain context about the CSV parsing\n      }\n    });\n  });\n});\n"
        }
    ]
}