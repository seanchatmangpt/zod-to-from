{
    "sourceFile": "test/features/fuzz-testing.test.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758645130119,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758645130119,
            "name": "Commit-0",
            "content": "/**\n * Fuzz Testing\n * @fileoverview Adversarial and fuzz testing for robust input validation\n */\n\nimport { join } from 'node:path';\nimport { beforeEach, describe, expect, it } from 'vitest';\nimport { z } from 'zod';\nimport { convert, formatTo, parseFrom } from '../../src/core/main.mjs';\n\ndescribe('Fuzz Testing', () => {\n  const SimpleSchema = z.object({\n    name: z.string(),\n    age: z.number(),\n    active: z.boolean(),\n  });\n\n  const ComplexSchema = z.object({\n    id: z.string(),\n    metadata: z.object({\n      tags: z.array(z.string()),\n      score: z.number().min(0).max(100),\n    }),\n    items: z.array(\n      z.object({\n        id: z.number(),\n        name: z.string(),\n        active: z.boolean(),\n      })\n    ),\n  });\n\n  const fixturesDir = join(process.cwd(), 'test', 'fixtures', 'adversarial');\n\n  beforeEach(() => {\n    // Ensure clean state for each test\n  });\n\n  describe('Adversarial Input Testing', () => {\n    it('should handle malformed JSON inputs', async () => {\n      const malformedInputs = [\n        '{\"name\": \"Test\", \"age\": 30, \"active\": true', // Missing closing brace\n        '{\"name\": \"Test\", \"age\": 30, \"active\": true,}', // Trailing comma\n        '{\"name\": \"Test\", \"age\": 30, \"active\": true, \"extra\": \"field\"}', // Extra field\n        '{\"name\": \"Test\", \"age\": \"not-a-number\", \"active\": true}', // Wrong type\n        '{\"name\": \"Test\", \"age\": 30}', // Missing required field\n        '{\"name\": \"Test\", \"age\": 30, \"active\": true, \"nested\": {\"circular\": \"reference\"}}', // Potential circular reference\n      ];\n\n      for (const input of malformedInputs) {\n        try {\n          await parseFrom(SimpleSchema, 'json', input);\n          // If it doesn't throw, that's also valid behavior\n        } catch (error) {\n          expect(error).toBeDefined();\n          expect(error.message).toBeDefined();\n        }\n      }\n    });\n\n    it('should handle malformed CSV inputs', async () => {\n      const malformedInputs = [\n        'name,age,active\\nJohn,30,true\\nJane,25', // Missing column\n        'name,age,active\\nJohn,30,true\\nJane,25,false,extra', // Extra column\n        'name,age,active\\nJohn,not-a-number,true', // Wrong type\n        'name,age,active\\nJohn,30', // Missing column\n        'name,age,active\\n\"John,30,true', // Unclosed quote\n        'name,age,active\\nJohn,30,true\\n\\nJane,25,false', // Empty lines\n      ];\n\n      for (const input of malformedInputs) {\n        try {\n          await parseFrom(SimpleSchema, 'csv', input);\n          // If it doesn't throw, that's also valid behavior\n        } catch (error) {\n          expect(error).toBeDefined();\n          expect(error.message).toBeDefined();\n        }\n      }\n    });\n\n    it('should handle malformed NDJSON inputs', async () => {\n      const malformedInputs = [\n        '{\"name\": \"John\", \"age\": 30, \"active\": true}\\n{\"name\": \"Jane\", \"age\": 25, \"active\": false,}', // Trailing comma\n        '{\"name\": \"John\", \"age\": 30, \"active\": true}\\nnot-json-line', // Invalid JSON line\n        '{\"name\": \"John\", \"age\": 30, \"active\": true}\\n{\"name\": \"Jane\", \"age\": \"not-a-number\", \"active\": false}', // Wrong type\n        '{\"name\": \"John\", \"age\": 30, \"active\": true}\\n{\"name\": \"Jane\", \"age\": 25}', // Missing field\n        '{\"name\": \"John\", \"age\": 30, \"active\": true}\\n\\n{\"name\": \"Jane\", \"age\": 25, \"active\": false}', // Empty lines\n      ];\n\n      for (const input of malformedInputs) {\n        try {\n          await parseFrom(SimpleSchema, 'ndjson', input);\n          // If it doesn't throw, that's also valid behavior\n        } catch (error) {\n          expect(error).toBeDefined();\n          expect(error.message).toBeDefined();\n        }\n      }\n    });\n\n    it('should handle empty and whitespace inputs', async () => {\n      const emptyInputs = ['', '   ', '\\n', '\\r\\n', '\\t', ' \\n \\r \\t '];\n\n      for (const input of emptyInputs) {\n        try {\n          await parseFrom(SimpleSchema, 'json', input);\n          // If it doesn't throw, that's also valid behavior\n        } catch (error) {\n          expect(error).toBeDefined();\n          expect(error.message).toBeDefined();\n        }\n      }\n    });\n\n    it('should handle very large inputs', async () => {\n      const largeInputs = [\n        '{\"name\": \"' + 'A'.repeat(1_000_000) + '\", \"age\": 30, \"active\": true}', // 1MB string\n        '{\"name\": \"Test\", \"age\": 30, \"active\": true, \"largeArray\": [' +\n          Array.from({ length: 10_000 }, (_, i) => i).join(',') +\n          ']}', // Large array\n        '{\"name\": \"Test\", \"age\": 30, \"active\": true, \"nested\": ' +\n          JSON.stringify(\n            Array.from({ length: 1000 }, (_, i) => ({ level: i, value: 'A'.repeat(1000) }))\n          ) +\n          '}', // Deep nesting\n      ];\n\n      for (const input of largeInputs) {\n        try {\n          await parseFrom(SimpleSchema, 'json', input);\n          // If it doesn't throw, that's also valid behavior\n        } catch (error) {\n          expect(error).toBeDefined();\n          expect(error.message).toBeDefined();\n        }\n      }\n    });\n\n    it('should handle special characters and unicode', async () => {\n      const specialInputs = [\n        '{\"name\": \"JosÃ© FranÃ§ois ä¸­æ–‡ ðŸš€\", \"age\": 30, \"active\": true}',\n        String.raw`{\"name\": \"Test with \\n\\r\\t\\\"\\'\\\\\", \"age\": 30, \"active\": true}`,\n        String.raw`{\"name\": \"Test with null\\u0000 character\", \"age\": 30, \"active\": true}`,\n        '{\"name\": \"Test with emoji ðŸŽ‰ðŸŽŠðŸŽˆ\", \"age\": 30, \"active\": true}',\n        '{\"name\": \"Test with math symbols âˆ‘âˆâˆ«âˆšâˆž\", \"age\": 30, \"active\": true}',\n      ];\n\n      for (const input of specialInputs) {\n        try {\n          const result = await parseFrom(SimpleSchema, 'json', input);\n          expect(result).toBeDefined();\n          expect(result.name).toBeDefined();\n        } catch (error) {\n          expect(error).toBeDefined();\n          expect(error.message).toBeDefined();\n        }\n      }\n    });\n  });\n\n  describe('Random Fuzz Testing', () => {\n    it('should handle random JSON-like strings', async () => {\n      const randomStrings = [\n        '{\"name\": \"Test\", \"age\": 30, \"active\": true}',\n        '{\"name\": \"Test\", \"age\": 30, \"active\": true, \"extra\": \"field\"}',\n        '{\"name\": \"Test\", \"age\": 30, \"active\": true, \"nested\": {\"value\": \"test\"}}',\n        '{\"name\": \"Test\", \"age\": 30, \"active\": true, \"array\": [1, 2, 3]}',\n        '{\"name\": \"Test\", \"age\": 30, \"active\": true, \"null\": null}',\n        '{\"name\": \"Test\", \"age\": 30, \"active\": true, \"boolean\": false}',\n        '{\"name\": \"Test\", \"age\": 30, \"active\": true, \"number\": 42.5}',\n        '{\"name\": \"Test\", \"age\": 30, \"active\": true, \"string\": \"hello world\"}',\n      ];\n\n      for (const input of randomStrings) {\n        try {\n          const result = await parseFrom(SimpleSchema, 'json', input);\n          expect(result).toBeDefined();\n        } catch (error) {\n          expect(error).toBeDefined();\n          expect(error.message).toBeDefined();\n        }\n      }\n    });\n\n    it('should handle random CSV-like strings', async () => {\n      const randomStrings = [\n        'name,age,active\\nJohn,30,true',\n        'name,age,active\\nJohn,30,true\\nJane,25,false',\n        'name,age,active\\n\"John, Doe\",30,true',\n        'name,age,active\\nJohn,30,true\\nJane,25,false\\nBob,35,true',\n        'name,age,active\\nJohn,30,true\\n\\nJane,25,false',\n        'name,age,active\\nJohn,30,true\\nJane,25,false\\n',\n      ];\n\n      for (const input of randomStrings) {\n        try {\n          const result = await parseFrom(SimpleSchema, 'csv', input);\n          expect(result).toBeDefined();\n        } catch (error) {\n          expect(error).toBeDefined();\n          expect(error.message).toBeDefined();\n        }\n      }\n    });\n\n    it('should handle random NDJSON-like strings', async () => {\n      const randomStrings = [\n        '{\"name\": \"John\", \"age\": 30, \"active\": true}',\n        '{\"name\": \"John\", \"age\": 30, \"active\": true}\\n{\"name\": \"Jane\", \"age\": 25, \"active\": false}',\n        '{\"name\": \"John\", \"age\": 30, \"active\": true}\\n\\n{\"name\": \"Jane\", \"age\": 25, \"active\": false}',\n        '{\"name\": \"John\", \"age\": 30, \"active\": true}\\n{\"name\": \"Jane\", \"age\": 25, \"active\": false}\\n',\n        '{\"name\": \"John\", \"age\": 30, \"active\": true, \"extra\": \"field\"}',\n        '{\"name\": \"John\", \"age\": 30, \"active\": true, \"nested\": {\"value\": \"test\"}}',\n      ];\n\n      for (const input of randomStrings) {\n        try {\n          const result = await parseFrom(SimpleSchema, 'ndjson', input);\n          expect(result).toBeDefined();\n        } catch (error) {\n          expect(error).toBeDefined();\n          expect(error.message).toBeDefined();\n        }\n      }\n    });\n  });\n\n  describe('Boundary Value Testing', () => {\n    it('should handle boundary values for numbers', async () => {\n      const boundaryValues = [\n        { name: 'Test', age: 0, active: true },\n        { name: 'Test', age: 1, active: true },\n        { name: 'Test', age: -1, active: true },\n        { name: 'Test', age: Number.MAX_SAFE_INTEGER, active: true },\n        { name: 'Test', age: Number.MIN_SAFE_INTEGER, active: true },\n        { name: 'Test', age: Infinity, active: true },\n        { name: 'Test', age: -Infinity, active: true },\n        { name: 'Test', age: Number.NaN, active: true },\n      ];\n\n      for (const data of boundaryValues) {\n        try {\n          const result = await formatTo(SimpleSchema, 'json', data);\n          expect(result).toBeDefined();\n        } catch (error) {\n          expect(error).toBeDefined();\n          expect(error.message).toBeDefined();\n        }\n      }\n    });\n\n    it('should handle boundary values for strings', async () => {\n      const boundaryValues = [\n        { name: '', age: 30, active: true },\n        { name: ' ', age: 30, active: true },\n        { name: 'A', age: 30, active: true },\n        { name: 'A'.repeat(1000), age: 30, active: true },\n        { name: 'A'.repeat(10_000), age: 30, active: true },\n        { name: 'A'.repeat(100_000), age: 30, active: true },\n      ];\n\n      for (const data of boundaryValues) {\n        try {\n          const result = await formatTo(SimpleSchema, 'json', data);\n          expect(result).toBeDefined();\n        } catch (error) {\n          expect(error).toBeDefined();\n          expect(error.message).toBeDefined();\n        }\n      }\n    });\n\n    it('should handle boundary values for booleans', async () => {\n      const boundaryValues = [\n        { name: 'Test', age: 30, active: true },\n        { name: 'Test', age: 30, active: false },\n      ];\n\n      for (const data of boundaryValues) {\n        try {\n          const result = await formatTo(SimpleSchema, 'json', data);\n          expect(result).toBeDefined();\n        } catch (error) {\n          expect(error).toBeDefined();\n          expect(error.message).toBeDefined();\n        }\n      }\n    });\n  });\n\n  describe('Stress Testing', () => {\n    it('should handle rapid successive operations', async () => {\n      const operations = [];\n      const data = { name: 'Test', age: 30, active: true };\n\n      // Create many operations\n      for (let i = 0; i < 100; i++) {\n        operations.push(formatTo(SimpleSchema, 'json', data));\n      }\n\n      // Execute all operations\n      const results = await Promise.all(operations);\n\n      // Verify all results\n      for (const result of results) {\n        expect(result).toBeDefined();\n        expect(result).toContain('\"name\": \"Test\"');\n        expect(result).toContain('\"age\": 30');\n        expect(result).toContain('\"active\": true');\n      }\n    });\n\n    it('should handle concurrent operations', async () => {\n      const concurrentOperations = [\n        parseFrom(SimpleSchema, 'json', '{\"name\": \"Test1\", \"age\": 30, \"active\": true}'),\n        parseFrom(SimpleSchema, 'json', '{\"name\": \"Test2\", \"age\": 25, \"active\": false}'),\n        parseFrom(SimpleSchema, 'json', '{\"name\": \"Test3\", \"age\": 35, \"active\": true}'),\n        formatTo(SimpleSchema, 'json', { name: 'Test4', age: 40, active: false }),\n        formatTo(SimpleSchema, 'json', { name: 'Test5', age: 45, active: true }),\n        convert(\n          SimpleSchema,\n          { from: 'json', to: 'json' },\n          '{\"name\": \"Test6\", \"age\": 50, \"active\": false}'\n        ),\n      ];\n\n      const results = await Promise.all(concurrentOperations);\n\n      for (const result of results) {\n        expect(result).toBeDefined();\n      }\n    });\n\n    it('should handle memory-intensive operations', async () => {\n      const largeData = {\n        name: 'Test',\n        age: 30,\n        active: true,\n        largeArray: Array.from({ length: 10_000 }, (_, i) => ({\n          id: i,\n          value: `item-${i}`,\n          data: 'A'.repeat(1000),\n        })),\n      };\n\n      const largeSchema = z.object({\n        name: z.string(),\n        age: z.number(),\n        active: z.boolean(),\n        largeArray: z.array(\n          z.object({\n            id: z.number(),\n            value: z.string(),\n            data: z.string(),\n          })\n        ),\n      });\n\n      try {\n        const result = await formatTo(largeSchema, 'json', largeData);\n        expect(result).toBeDefined();\n        expect(result.length).toBeGreaterThan(1_000_000); // Should be large\n      } catch (error) {\n        expect(error).toBeDefined();\n        expect(error.message).toBeDefined();\n      }\n    });\n  });\n\n  describe('Error Recovery Testing', () => {\n    it('should recover from parse errors', async () => {\n      const validInput = '{\"name\": \"Test\", \"age\": 30, \"active\": true}';\n      const invalidInput = '{\"name\": \"Test\", \"age\": \"not-a-number\", \"active\": true}';\n\n      // First, parse valid input\n      const validResult = await parseFrom(SimpleSchema, 'json', validInput);\n      expect(validResult).toBeDefined();\n\n      // Then, try to parse invalid input\n      try {\n        await parseFrom(SimpleSchema, 'json', invalidInput);\n        expect.fail('Should have thrown an error');\n      } catch (error) {\n        expect(error).toBeDefined();\n      }\n\n      // Finally, parse valid input again to ensure recovery\n      const recoveredResult = await parseFrom(SimpleSchema, 'json', validInput);\n      expect(recoveredResult).toBeDefined();\n      expect(recoveredResult).toEqual(validResult);\n    });\n\n    it('should recover from format errors', async () => {\n      const validData = { name: 'Test', age: 30, active: true };\n      const invalidData = { name: 'Test', age: 'not-a-number', active: true };\n\n      // First, format valid data\n      const validResult = await formatTo(SimpleSchema, 'json', validData);\n      expect(validResult).toBeDefined();\n\n      // Then, try to format invalid data\n      try {\n        await formatTo(SimpleSchema, 'json', invalidData);\n        expect.fail('Should have thrown an error');\n      } catch (error) {\n        expect(error).toBeDefined();\n      }\n\n      // Finally, format valid data again to ensure recovery\n      const recoveredResult = await formatTo(SimpleSchema, 'json', validData);\n      expect(recoveredResult).toBeDefined();\n      expect(recoveredResult).toEqual(validResult);\n    });\n\n    it('should recover from conversion errors', async () => {\n      const validInput = '{\"name\": \"Test\", \"age\": 30, \"active\": true}';\n      const invalidInput = '{\"name\": \"Test\", \"age\": \"not-a-number\", \"active\": true}';\n\n      // First, convert valid input\n      const validResult = await convert(SimpleSchema, { from: 'json', to: 'json' }, validInput);\n      expect(validResult).toBeDefined();\n\n      // Then, try to convert invalid input\n      try {\n        await convert(SimpleSchema, { from: 'json', to: 'json' }, invalidInput);\n        expect.fail('Should have thrown an error');\n      } catch (error) {\n        expect(error).toBeDefined();\n      }\n\n      // Finally, convert valid input again to ensure recovery\n      const recoveredResult = await convert(SimpleSchema, { from: 'json', to: 'json' }, validInput);\n      expect(recoveredResult).toBeDefined();\n      expect(recoveredResult).toEqual(validResult);\n    });\n  });\n\n  describe('Performance Under Load', () => {\n    it('should maintain performance with many small operations', async () => {\n      const startTime = Date.now();\n      const operations = [];\n\n      for (let i = 0; i < 1000; i++) {\n        operations.push(\n          parseFrom(SimpleSchema, 'json', '{\"name\": \"Test\", \"age\": 30, \"active\": true}')\n        );\n      }\n\n      const results = await Promise.all(operations);\n      const endTime = Date.now();\n      const duration = endTime - startTime;\n\n      expect(results).toHaveLength(1000);\n      expect(duration).toBeLessThan(5000); // Should complete within 5 seconds\n    });\n\n    it('should maintain performance with large data operations', async () => {\n      const largeData = {\n        name: 'Test',\n        age: 30,\n        active: true,\n        largeArray: Array.from({ length: 1000 }, (_, i) => ({\n          id: i,\n          value: `item-${i}`,\n        })),\n      };\n\n      const largeSchema = z.object({\n        name: z.string(),\n        age: z.number(),\n        active: z.boolean(),\n        largeArray: z.array(\n          z.object({\n            id: z.number(),\n            value: z.string(),\n          })\n        ),\n      });\n\n      const startTime = Date.now();\n      const result = await formatTo(largeSchema, 'json', largeData);\n      const endTime = Date.now();\n      const duration = endTime - startTime;\n\n      expect(result).toBeDefined();\n      expect(duration).toBeLessThan(2000); // Should complete within 2 seconds\n    });\n  });\n});\n"
        }
    ]
}