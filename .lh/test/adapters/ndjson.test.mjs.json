{
    "sourceFile": "test/adapters/ndjson.test.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1758645130119,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758645941380,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,530 @@\n+/**\n+ * NDJSON Adapter Tests\n+ * @fileoverview Comprehensive tests for Newline Delimited JSON parsing and formatting\n+ */\n+\n+import { beforeEach, describe, expect, it } from 'vitest';\n+import { z } from 'zod';\n+import { convert, formatTo, parseFrom } from '../setup.mjs';\n+\n+describe('NDJSON Adapter', () => {\n+  const SimpleNDJSONSchema = z.object({\n+    items: z.array(\n+      z.object({\n+        name: z.string(),\n+        age: z.number(),\n+        active: z.boolean(),\n+      })\n+    ),\n+  });\n+\n+  const ComplexNDJSONSchema = z.object({\n+    items: z.array(\n+      z.object({\n+        id: z.string(),\n+        metadata: z.object({\n+          tags: z.array(z.string()),\n+          score: z.number(),\n+        }),\n+        nested: z.object({\n+          value: z.string(),\n+          optional: z.string().optional(),\n+        }),\n+      })\n+    ),\n+  });\n+\n+  beforeEach(() => {\n+    // Ensure clean state for each test\n+  });\n+\n+  describe('NDJSON Parsing', () => {\n+    it('should parse simple NDJSON input', async () => {\n+      const ndjsonInput = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n+{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n+\n+      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput);\n+\n+      expect(result.items).toHaveLength(2);\n+      expect(result.items[0]).toEqual({\n+        name: 'John',\n+        age: 30,\n+        active: true,\n+      });\n+      expect(result.items[1]).toEqual({\n+        name: 'Jane',\n+        age: 25,\n+        active: false,\n+      });\n+    });\n+\n+    it('should handle single line NDJSON', async () => {\n+      const ndjsonInput = '{\"name\": \"Single\", \"age\": 42, \"active\": true}';\n+\n+      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput);\n+\n+      expect(result.items).toHaveLength(1);\n+      expect(result.items[0]).toEqual({\n+        name: 'Single',\n+        age: 42,\n+        active: true,\n+      });\n+    });\n+\n+    it('should handle empty NDJSON input', async () => {\n+      const ndjsonInput = '';\n+\n+      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput);\n+\n+      expect(result.items).toHaveLength(0);\n+    });\n+\n+    it('should handle NDJSON with trailing newline', async () => {\n+      const ndjsonInput = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n+{\"name\": \"Jane\", \"age\": 25, \"active\": false}\n+`;\n+\n+      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput);\n+\n+      expect(result.items).toHaveLength(2);\n+      expect(result.items[0].name).toBe('John');\n+      expect(result.items[1].name).toBe('Jane');\n+    });\n+\n+    it('should handle NDJSON with empty lines', async () => {\n+      const ndjsonInput = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n+\n+{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n+\n+      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput);\n+\n+      expect(result.items).toHaveLength(2);\n+      expect(result.items[0].name).toBe('John');\n+      expect(result.items[1].name).toBe('Jane');\n+    });\n+\n+    it('should handle complex nested NDJSON', async () => {\n+      const ndjsonInput = `{\"id\": \"1\", \"metadata\": {\"tags\": [\"important\"], \"score\": 85}, \"nested\": {\"value\": \"test1\"}}\n+{\"id\": \"2\", \"metadata\": {\"tags\": [\"urgent\"], \"score\": 90}, \"nested\": {\"value\": \"test2\", \"optional\": \"present\"}}`;\n+\n+      const result = await parseFrom(ComplexNDJSONSchema, 'ndjson', ndjsonInput);\n+\n+      expect(result.items).toHaveLength(2);\n+      expect(result.items[0]).toEqual({\n+        id: '1',\n+        metadata: {\n+          tags: ['important'],\n+          score: 85,\n+        },\n+        nested: {\n+          value: 'test1',\n+        },\n+      });\n+      expect(result.items[1]).toEqual({\n+        id: '2',\n+        metadata: {\n+          tags: ['urgent'],\n+          score: 90,\n+        },\n+        nested: {\n+          value: 'test2',\n+          optional: 'present',\n+        },\n+      });\n+    });\n+\n+    it('should throw error for malformed JSON line', async () => {\n+      const malformedNDJSON = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n+{\"name\": \"Jane\", \"age\": 25, \"active\": false,}`; // Trailing comma\n+\n+      await expect(parseFrom(SimpleNDJSONSchema, 'ndjson', malformedNDJSON)).rejects.toThrow();\n+    });\n+\n+    it('should throw error for invalid JSON line', async () => {\n+      const invalidNDJSON = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n+not-json-line\n+{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n+\n+      await expect(parseFrom(SimpleNDJSONSchema, 'ndjson', invalidNDJSON)).rejects.toThrow();\n+    });\n+  });\n+\n+  describe('NDJSON Formatting', () => {\n+    it('should format array data to NDJSON', async () => {\n+      const data = {\n+        items: [\n+          { name: 'John', age: 30, active: true },\n+          { name: 'Jane', age: 25, active: false },\n+        ],\n+      };\n+\n+      const result = await formatTo(SimpleNDJSONSchema, 'ndjson', data);\n+\n+      const lines = result.trim().split('\\n');\n+      expect(lines).toHaveLength(2);\n+      expect(JSON.parse(lines[0])).toEqual({ name: 'John', age: 30, active: true });\n+      expect(JSON.parse(lines[1])).toEqual({ name: 'Jane', age: 25, active: false });\n+    });\n+\n+    it('should format single object to NDJSON', async () => {\n+      const data = {\n+        items: [{ name: 'Single', age: 42, active: true }],\n+      };\n+\n+      const result = await formatTo(SimpleNDJSONSchema, 'ndjson', data);\n+\n+      const lines = result.trim().split('\\n');\n+      expect(lines).toHaveLength(1);\n+      expect(JSON.parse(lines[0])).toEqual({ name: 'Single', age: 42, active: true });\n+    });\n+\n+    it('should handle empty array formatting', async () => {\n+      const data = { items: [] };\n+\n+      const result = await formatTo(SimpleNDJSONSchema, 'ndjson', data);\n+\n+      expect(result.trim()).toBe('');\n+    });\n+\n+    it('should format complex nested data to NDJSON', async () => {\n+      const data = {\n+        items: [\n+          {\n+            id: '1',\n+            metadata: {\n+              tags: ['important'],\n+              score: 85,\n+            },\n+            nested: {\n+              value: 'test1',\n+            },\n+          },\n+          {\n+            id: '2',\n+            metadata: {\n+              tags: ['urgent'],\n+              score: 90,\n+            },\n+            nested: {\n+              value: 'test2',\n+              optional: 'present',\n+            },\n+          },\n+        ],\n+      };\n+\n+      const result = await formatTo(ComplexNDJSONSchema, 'ndjson', data);\n+\n+      const lines = result.trim().split('\\n');\n+      expect(lines).toHaveLength(2);\n+\n+      const parsed1 = JSON.parse(lines[0]);\n+      expect(parsed1.id).toBe('1');\n+      expect(parsed1.metadata.tags).toEqual(['important']);\n+      expect(parsed1.nested.value).toBe('test1');\n+\n+      const parsed2 = JSON.parse(lines[1]);\n+      expect(parsed2.id).toBe('2');\n+      expect(parsed2.metadata.tags).toEqual(['urgent']);\n+      expect(parsed2.nested.optional).toBe('present');\n+    });\n+\n+    it('should handle special characters in NDJSON formatting', async () => {\n+      const data = {\n+        items: [\n+          { name: 'John \"The Great\"', age: 30, active: true },\n+          { name: 'Jane\\nSmith', age: 25, active: false },\n+        ],\n+      };\n+\n+      const result = await formatTo(SimpleNDJSONSchema, 'ndjson', data);\n+\n+      const lines = result.trim().split('\\n');\n+      expect(lines).toHaveLength(2);\n+      expect(JSON.parse(lines[0]).name).toBe('John \"The Great\"');\n+      expect(JSON.parse(lines[1]).name).toBe('Jane\\nSmith');\n+    });\n+  });\n+\n+  describe('NDJSON Round-Trip Testing', () => {\n+    it('should maintain data integrity through parse-format round-trip', async () => {\n+      const originalNDJSON = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n+{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n+\n+      // Parse then format\n+      const parsed = await parseFrom(SimpleNDJSONSchema, 'ndjson', originalNDJSON);\n+      const formatted = await formatTo(SimpleNDJSONSchema, 'ndjson', parsed);\n+\n+      // Parse the formatted result\n+      const roundTripParsed = await parseFrom(SimpleNDJSONSchema, 'ndjson', formatted);\n+\n+      expect(roundTripParsed.items).toHaveLength(2);\n+      expect(roundTripParsed.items[0]).toEqual({\n+        name: 'John',\n+        age: 30,\n+        active: true,\n+      });\n+      expect(roundTripParsed.items[1]).toEqual({\n+        name: 'Jane',\n+        age: 25,\n+        active: false,\n+      });\n+    });\n+\n+    it('should handle round-trip with complex nested data', async () => {\n+      const originalNDJSON = `{\"id\": \"1\", \"metadata\": {\"tags\": [\"important\"], \"score\": 85}, \"nested\": {\"value\": \"test1\"}}\n+{\"id\": \"2\", \"metadata\": {\"tags\": [\"urgent\"], \"score\": 90}, \"nested\": {\"value\": \"test2\", \"optional\": \"present\"}}`;\n+\n+      // Parse then format\n+      const parsed = await parseFrom(ComplexNDJSONSchema, 'ndjson', originalNDJSON);\n+      const formatted = await formatTo(ComplexNDJSONSchema, 'ndjson', parsed);\n+\n+      // Parse the formatted result\n+      const roundTripParsed = await parseFrom(ComplexNDJSONSchema, 'ndjson', formatted);\n+\n+      expect(roundTripParsed.items).toHaveLength(2);\n+      expect(roundTripParsed.items[0].id).toBe('1');\n+      expect(roundTripParsed.items[1].nested.optional).toBe('present');\n+    });\n+\n+    it('should handle round-trip with special characters', async () => {\n+      const originalNDJSON = `{\"name\": \"John \\\\\"The Great\\\\\"\", \"age\": 30, \"active\": true}\n+{\"name\": \"Jane\\\\nSmith\", \"age\": 25, \"active\": false}`;\n+\n+      // Parse then format\n+      const parsed = await parseFrom(SimpleNDJSONSchema, 'ndjson', originalNDJSON);\n+      const formatted = await formatTo(SimpleNDJSONSchema, 'ndjson', parsed);\n+\n+      // Parse the formatted result\n+      const roundTripParsed = await parseFrom(SimpleNDJSONSchema, 'ndjson', formatted);\n+\n+      expect(roundTripParsed.items).toHaveLength(2);\n+      expect(roundTripParsed.items[0].name).toBe('John \"The Great\"');\n+      expect(roundTripParsed.items[1].name).toBe('Jane\\nSmith');\n+    });\n+  });\n+\n+  describe('NDJSON Conversion', () => {\n+    it('should convert NDJSON to JSON', async () => {\n+      const ndjsonInput = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n+{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n+\n+      const result = await convert(SimpleNDJSONSchema, { from: 'ndjson', to: 'json' }, ndjsonInput);\n+\n+      const parsedResult = JSON.parse(result);\n+      expect(parsedResult.items).toHaveLength(2);\n+      expect(parsedResult.items[0]).toEqual({\n+        name: 'John',\n+        age: 30,\n+        active: true,\n+      });\n+    });\n+\n+    it('should convert JSON to NDJSON', async () => {\n+      const jsonInput = JSON.stringify({\n+        items: [\n+          { name: 'John', age: 30, active: true },\n+          { name: 'Jane', age: 25, active: false },\n+        ],\n+      });\n+\n+      const result = await convert(SimpleNDJSONSchema, { from: 'json', to: 'ndjson' }, jsonInput);\n+\n+      const lines = result.trim().split('\\n');\n+      expect(lines).toHaveLength(2);\n+      expect(JSON.parse(lines[0])).toEqual({ name: 'John', age: 30, active: true });\n+      expect(JSON.parse(lines[1])).toEqual({ name: 'Jane', age: 25, active: false });\n+    });\n+\n+    it('should convert NDJSON to CSV', async () => {\n+      const ndjsonInput = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n+{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n+\n+      const result = await convert(SimpleNDJSONSchema, { from: 'ndjson', to: 'csv' }, ndjsonInput);\n+\n+      expect(result).toContain('name,age,active');\n+      expect(result).toContain('John,30,true');\n+      expect(result).toContain('Jane,25,false');\n+    });\n+\n+    it('should convert CSV to NDJSON', async () => {\n+      const csvInput = `name,age,active\n+John,30,true\n+Jane,25,false`;\n+\n+      const result = await convert(SimpleNDJSONSchema, { from: 'csv', to: 'ndjson' }, csvInput);\n+\n+      const lines = result.trim().split('\\n');\n+      expect(lines).toHaveLength(2);\n+      expect(JSON.parse(lines[0])).toEqual({ name: 'John', age: 30, active: true });\n+      expect(JSON.parse(lines[1])).toEqual({ name: 'Jane', age: 25, active: false });\n+    });\n+  });\n+\n+  describe('NDJSON Error Handling', () => {\n+    it('should handle empty input gracefully', async () => {\n+      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', '');\n+      expect(result.items).toHaveLength(0);\n+    });\n+\n+    it('should handle whitespace-only input', async () => {\n+      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', '   \\n  \\n  ');\n+      expect(result.items).toHaveLength(0);\n+    });\n+\n+    it('should throw error for malformed JSON line', async () => {\n+      const malformedNDJSON = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n+{\"name\": \"Jane\", \"age\": 25, \"active\": false,}`; // Trailing comma\n+\n+      await expect(parseFrom(SimpleNDJSONSchema, 'ndjson', malformedNDJSON)).rejects.toThrow();\n+    });\n+\n+    it('should throw error for invalid JSON line', async () => {\n+      const invalidNDJSON = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n+not-json-line\n+{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n+\n+      await expect(parseFrom(SimpleNDJSONSchema, 'ndjson', invalidNDJSON)).rejects.toThrow();\n+    });\n+\n+    it('should handle schema validation errors', async () => {\n+      const invalidNDJSON = `{\"name\": \"John\", \"age\": \"not-a-number\", \"active\": true}`;\n+\n+      await expect(parseFrom(SimpleNDJSONSchema, 'ndjson', invalidNDJSON)).rejects.toThrow();\n+    });\n+  });\n+\n+  describe('NDJSON Streaming Support', () => {\n+    it('should support streaming operations', async () => {\n+      const ndjsonInput = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n+{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n+\n+      // Should work with streaming enabled\n+      await expect(\n+        parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput, { streaming: true })\n+      ).resolves.toBeDefined();\n+      await expect(\n+        formatTo(SimpleNDJSONSchema, 'ndjson', { items: [] }, { streaming: true })\n+      ).resolves.toBeDefined();\n+    });\n+\n+    it('should handle large NDJSON files efficiently', async () => {\n+      // Generate large NDJSON\n+      const lines = Array.from({ length: 1000 }, (_, i) =>\n+        JSON.stringify({ name: `Person${i}`, age: 20 + i, active: i % 2 === 0 })\n+      ).join('\\n');\n+\n+      const startTime = Date.now();\n+      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', lines);\n+      const endTime = Date.now();\n+\n+      expect(result.items).toHaveLength(1000);\n+      expect(endTime - startTime).toBeLessThan(1000); // Should complete within 1 second\n+    });\n+\n+    it('should handle streaming with async iterables', async () => {\n+      // This test would be expanded when streaming async iterables are implemented\n+      const ndjsonInput = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n+{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n+\n+      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput, {\n+        streaming: true,\n+      });\n+      expect(result.items).toHaveLength(2);\n+    });\n+  });\n+\n+  describe('NDJSON Metadata', () => {\n+    it('should include metadata in parse results', async () => {\n+      const ndjsonInput = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n+{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n+\n+      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput, {\n+        includeProvenance: true,\n+      });\n+\n+      expect(result).toHaveProperty('data');\n+      expect(result).toHaveProperty('provenance');\n+      expect(result.provenance).toHaveProperty('adapter', 'ndjson');\n+      expect(result.provenance).toHaveProperty('sourceFormat', 'ndjson');\n+    });\n+\n+    it('should include metadata in format results', async () => {\n+      const data = {\n+        items: [{ name: 'John', age: 30, active: true }],\n+      };\n+\n+      const result = await formatTo(SimpleNDJSONSchema, 'ndjson', data, {\n+        includeProvenance: true,\n+      });\n+\n+      expect(result).toHaveProperty('data');\n+      expect(result).toHaveProperty('provenance');\n+      expect(result.provenance).toHaveProperty('adapter', 'ndjson');\n+      expect(result.provenance).toHaveProperty('targetFormat', 'ndjson');\n+    });\n+  });\n+\n+  describe('NDJSON Edge Cases', () => {\n+    it('should handle NDJSON with unicode characters', async () => {\n+      const ndjsonInput = `{\"name\": \"José\", \"age\": 30, \"active\": true}\n+{\"name\": \"François\", \"age\": 25, \"active\": false}`;\n+\n+      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput);\n+\n+      expect(result.items).toHaveLength(2);\n+      expect(result.items[0].name).toBe('José');\n+      expect(result.items[1].name).toBe('François');\n+    });\n+\n+    it('should handle NDJSON with very long lines', async () => {\n+      const longName = 'A'.repeat(10_000);\n+      const ndjsonInput = `{\"name\": \"${longName}\", \"age\": 30, \"active\": true}`;\n+\n+      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput);\n+\n+      expect(result.items).toHaveLength(1);\n+      expect(result.items[0].name).toBe(longName);\n+    });\n+\n+    it('should handle NDJSON with deeply nested objects', async () => {\n+      const deepNested = {\n+        level1: {\n+          level2: {\n+            level3: {\n+              level4: {\n+                level5: {\n+                  value: 'deep',\n+                },\n+              },\n+            },\n+          },\n+        },\n+      };\n+\n+      const ndjsonInput = JSON.stringify(deepNested);\n+      const schema = z.object({\n+        items: z.array(\n+          z.object({\n+            level1: z.object({\n+              level2: z.object({\n+                level3: z.object({\n+                  level4: z.object({\n+                    level5: z.object({\n+                      value: z.string(),\n+                    }),\n+                  }),\n+                }),\n+              }),\n+            }),\n+          })\n+        ),\n+      });\n+\n+      const result = await parseFrom(schema, 'ndjson', ndjsonInput);\n+\n+      expect(result.items).toHaveLength(1);\n+      expect(result.items[0].level1.level2.level3.level4.level5.value).toBe('deep');\n+    });\n+  });\n+});\n"
                }
            ],
            "date": 1758645130119,
            "name": "Commit-0",
            "content": "/**\n * NDJSON Adapter Tests\n * @fileoverview Comprehensive tests for Newline Delimited JSON parsing and formatting\n */\n\nimport { beforeEach, describe, expect, it } from 'vitest';\nimport { z } from 'zod';\nimport { convert, formatTo, parseFrom } from '../../src/core/main.mjs';\n\ndescribe('NDJSON Adapter', () => {\n  const SimpleNDJSONSchema = z.object({\n    items: z.array(\n      z.object({\n        name: z.string(),\n        age: z.number(),\n        active: z.boolean(),\n      })\n    ),\n  });\n\n  const ComplexNDJSONSchema = z.object({\n    items: z.array(\n      z.object({\n        id: z.string(),\n        metadata: z.object({\n          tags: z.array(z.string()),\n          score: z.number(),\n        }),\n        nested: z.object({\n          value: z.string(),\n          optional: z.string().optional(),\n        }),\n      })\n    ),\n  });\n\n  beforeEach(() => {\n    // Ensure clean state for each test\n  });\n\n  describe('NDJSON Parsing', () => {\n    it('should parse simple NDJSON input', async () => {\n      const ndjsonInput = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n\n      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput);\n\n      expect(result.items).toHaveLength(2);\n      expect(result.items[0]).toEqual({\n        name: 'John',\n        age: 30,\n        active: true,\n      });\n      expect(result.items[1]).toEqual({\n        name: 'Jane',\n        age: 25,\n        active: false,\n      });\n    });\n\n    it('should handle single line NDJSON', async () => {\n      const ndjsonInput = '{\"name\": \"Single\", \"age\": 42, \"active\": true}';\n\n      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput);\n\n      expect(result.items).toHaveLength(1);\n      expect(result.items[0]).toEqual({\n        name: 'Single',\n        age: 42,\n        active: true,\n      });\n    });\n\n    it('should handle empty NDJSON input', async () => {\n      const ndjsonInput = '';\n\n      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput);\n\n      expect(result.items).toHaveLength(0);\n    });\n\n    it('should handle NDJSON with trailing newline', async () => {\n      const ndjsonInput = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n{\"name\": \"Jane\", \"age\": 25, \"active\": false}\n`;\n\n      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput);\n\n      expect(result.items).toHaveLength(2);\n      expect(result.items[0].name).toBe('John');\n      expect(result.items[1].name).toBe('Jane');\n    });\n\n    it('should handle NDJSON with empty lines', async () => {\n      const ndjsonInput = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n\n{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n\n      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput);\n\n      expect(result.items).toHaveLength(2);\n      expect(result.items[0].name).toBe('John');\n      expect(result.items[1].name).toBe('Jane');\n    });\n\n    it('should handle complex nested NDJSON', async () => {\n      const ndjsonInput = `{\"id\": \"1\", \"metadata\": {\"tags\": [\"important\"], \"score\": 85}, \"nested\": {\"value\": \"test1\"}}\n{\"id\": \"2\", \"metadata\": {\"tags\": [\"urgent\"], \"score\": 90}, \"nested\": {\"value\": \"test2\", \"optional\": \"present\"}}`;\n\n      const result = await parseFrom(ComplexNDJSONSchema, 'ndjson', ndjsonInput);\n\n      expect(result.items).toHaveLength(2);\n      expect(result.items[0]).toEqual({\n        id: '1',\n        metadata: {\n          tags: ['important'],\n          score: 85,\n        },\n        nested: {\n          value: 'test1',\n        },\n      });\n      expect(result.items[1]).toEqual({\n        id: '2',\n        metadata: {\n          tags: ['urgent'],\n          score: 90,\n        },\n        nested: {\n          value: 'test2',\n          optional: 'present',\n        },\n      });\n    });\n\n    it('should throw error for malformed JSON line', async () => {\n      const malformedNDJSON = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n{\"name\": \"Jane\", \"age\": 25, \"active\": false,}`; // Trailing comma\n\n      await expect(parseFrom(SimpleNDJSONSchema, 'ndjson', malformedNDJSON)).rejects.toThrow();\n    });\n\n    it('should throw error for invalid JSON line', async () => {\n      const invalidNDJSON = `{\"name\": \"John\", \"age\": 30, \"active\": true}\nnot-json-line\n{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n\n      await expect(parseFrom(SimpleNDJSONSchema, 'ndjson', invalidNDJSON)).rejects.toThrow();\n    });\n  });\n\n  describe('NDJSON Formatting', () => {\n    it('should format array data to NDJSON', async () => {\n      const data = {\n        items: [\n          { name: 'John', age: 30, active: true },\n          { name: 'Jane', age: 25, active: false },\n        ],\n      };\n\n      const result = await formatTo(SimpleNDJSONSchema, 'ndjson', data);\n\n      const lines = result.trim().split('\\n');\n      expect(lines).toHaveLength(2);\n      expect(JSON.parse(lines[0])).toEqual({ name: 'John', age: 30, active: true });\n      expect(JSON.parse(lines[1])).toEqual({ name: 'Jane', age: 25, active: false });\n    });\n\n    it('should format single object to NDJSON', async () => {\n      const data = {\n        items: [{ name: 'Single', age: 42, active: true }],\n      };\n\n      const result = await formatTo(SimpleNDJSONSchema, 'ndjson', data);\n\n      const lines = result.trim().split('\\n');\n      expect(lines).toHaveLength(1);\n      expect(JSON.parse(lines[0])).toEqual({ name: 'Single', age: 42, active: true });\n    });\n\n    it('should handle empty array formatting', async () => {\n      const data = { items: [] };\n\n      const result = await formatTo(SimpleNDJSONSchema, 'ndjson', data);\n\n      expect(result.trim()).toBe('');\n    });\n\n    it('should format complex nested data to NDJSON', async () => {\n      const data = {\n        items: [\n          {\n            id: '1',\n            metadata: {\n              tags: ['important'],\n              score: 85,\n            },\n            nested: {\n              value: 'test1',\n            },\n          },\n          {\n            id: '2',\n            metadata: {\n              tags: ['urgent'],\n              score: 90,\n            },\n            nested: {\n              value: 'test2',\n              optional: 'present',\n            },\n          },\n        ],\n      };\n\n      const result = await formatTo(ComplexNDJSONSchema, 'ndjson', data);\n\n      const lines = result.trim().split('\\n');\n      expect(lines).toHaveLength(2);\n\n      const parsed1 = JSON.parse(lines[0]);\n      expect(parsed1.id).toBe('1');\n      expect(parsed1.metadata.tags).toEqual(['important']);\n      expect(parsed1.nested.value).toBe('test1');\n\n      const parsed2 = JSON.parse(lines[1]);\n      expect(parsed2.id).toBe('2');\n      expect(parsed2.metadata.tags).toEqual(['urgent']);\n      expect(parsed2.nested.optional).toBe('present');\n    });\n\n    it('should handle special characters in NDJSON formatting', async () => {\n      const data = {\n        items: [\n          { name: 'John \"The Great\"', age: 30, active: true },\n          { name: 'Jane\\nSmith', age: 25, active: false },\n        ],\n      };\n\n      const result = await formatTo(SimpleNDJSONSchema, 'ndjson', data);\n\n      const lines = result.trim().split('\\n');\n      expect(lines).toHaveLength(2);\n      expect(JSON.parse(lines[0]).name).toBe('John \"The Great\"');\n      expect(JSON.parse(lines[1]).name).toBe('Jane\\nSmith');\n    });\n  });\n\n  describe('NDJSON Round-Trip Testing', () => {\n    it('should maintain data integrity through parse-format round-trip', async () => {\n      const originalNDJSON = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n\n      // Parse then format\n      const parsed = await parseFrom(SimpleNDJSONSchema, 'ndjson', originalNDJSON);\n      const formatted = await formatTo(SimpleNDJSONSchema, 'ndjson', parsed);\n\n      // Parse the formatted result\n      const roundTripParsed = await parseFrom(SimpleNDJSONSchema, 'ndjson', formatted);\n\n      expect(roundTripParsed.items).toHaveLength(2);\n      expect(roundTripParsed.items[0]).toEqual({\n        name: 'John',\n        age: 30,\n        active: true,\n      });\n      expect(roundTripParsed.items[1]).toEqual({\n        name: 'Jane',\n        age: 25,\n        active: false,\n      });\n    });\n\n    it('should handle round-trip with complex nested data', async () => {\n      const originalNDJSON = `{\"id\": \"1\", \"metadata\": {\"tags\": [\"important\"], \"score\": 85}, \"nested\": {\"value\": \"test1\"}}\n{\"id\": \"2\", \"metadata\": {\"tags\": [\"urgent\"], \"score\": 90}, \"nested\": {\"value\": \"test2\", \"optional\": \"present\"}}`;\n\n      // Parse then format\n      const parsed = await parseFrom(ComplexNDJSONSchema, 'ndjson', originalNDJSON);\n      const formatted = await formatTo(ComplexNDJSONSchema, 'ndjson', parsed);\n\n      // Parse the formatted result\n      const roundTripParsed = await parseFrom(ComplexNDJSONSchema, 'ndjson', formatted);\n\n      expect(roundTripParsed.items).toHaveLength(2);\n      expect(roundTripParsed.items[0].id).toBe('1');\n      expect(roundTripParsed.items[1].nested.optional).toBe('present');\n    });\n\n    it('should handle round-trip with special characters', async () => {\n      const originalNDJSON = `{\"name\": \"John \"The Great\"\", \"age\": 30, \"active\": true}\n{\"name\": \"Jane\\nSmith\", \"age\": 25, \"active\": false}`;\n\n      // Parse then format\n      const parsed = await parseFrom(SimpleNDJSONSchema, 'ndjson', originalNDJSON);\n      const formatted = await formatTo(SimpleNDJSONSchema, 'ndjson', parsed);\n\n      // Parse the formatted result\n      const roundTripParsed = await parseFrom(SimpleNDJSONSchema, 'ndjson', formatted);\n\n      expect(roundTripParsed.items).toHaveLength(2);\n      expect(roundTripParsed.items[0].name).toBe('John \"The Great\"');\n      expect(roundTripParsed.items[1].name).toBe('Jane\\nSmith');\n    });\n  });\n\n  describe('NDJSON Conversion', () => {\n    it('should convert NDJSON to JSON', async () => {\n      const ndjsonInput = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n\n      const result = await convert(SimpleNDJSONSchema, { from: 'ndjson', to: 'json' }, ndjsonInput);\n\n      const parsedResult = JSON.parse(result);\n      expect(parsedResult.items).toHaveLength(2);\n      expect(parsedResult.items[0]).toEqual({\n        name: 'John',\n        age: 30,\n        active: true,\n      });\n    });\n\n    it('should convert JSON to NDJSON', async () => {\n      const jsonInput = JSON.stringify({\n        items: [\n          { name: 'John', age: 30, active: true },\n          { name: 'Jane', age: 25, active: false },\n        ],\n      });\n\n      const result = await convert(SimpleNDJSONSchema, { from: 'json', to: 'ndjson' }, jsonInput);\n\n      const lines = result.trim().split('\\n');\n      expect(lines).toHaveLength(2);\n      expect(JSON.parse(lines[0])).toEqual({ name: 'John', age: 30, active: true });\n      expect(JSON.parse(lines[1])).toEqual({ name: 'Jane', age: 25, active: false });\n    });\n\n    it('should convert NDJSON to CSV', async () => {\n      const ndjsonInput = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n\n      const result = await convert(SimpleNDJSONSchema, { from: 'ndjson', to: 'csv' }, ndjsonInput);\n\n      expect(result).toContain('name,age,active');\n      expect(result).toContain('John,30,true');\n      expect(result).toContain('Jane,25,false');\n    });\n\n    it('should convert CSV to NDJSON', async () => {\n      const csvInput = `name,age,active\nJohn,30,true\nJane,25,false`;\n\n      const result = await convert(SimpleNDJSONSchema, { from: 'csv', to: 'ndjson' }, csvInput);\n\n      const lines = result.trim().split('\\n');\n      expect(lines).toHaveLength(2);\n      expect(JSON.parse(lines[0])).toEqual({ name: 'John', age: 30, active: true });\n      expect(JSON.parse(lines[1])).toEqual({ name: 'Jane', age: 25, active: false });\n    });\n  });\n\n  describe('NDJSON Error Handling', () => {\n    it('should handle empty input gracefully', async () => {\n      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', '');\n      expect(result.items).toHaveLength(0);\n    });\n\n    it('should handle whitespace-only input', async () => {\n      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', '   \\n  \\n  ');\n      expect(result.items).toHaveLength(0);\n    });\n\n    it('should throw error for malformed JSON line', async () => {\n      const malformedNDJSON = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n{\"name\": \"Jane\", \"age\": 25, \"active\": false,}`; // Trailing comma\n\n      await expect(parseFrom(SimpleNDJSONSchema, 'ndjson', malformedNDJSON)).rejects.toThrow();\n    });\n\n    it('should throw error for invalid JSON line', async () => {\n      const invalidNDJSON = `{\"name\": \"John\", \"age\": 30, \"active\": true}\nnot-json-line\n{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n\n      await expect(parseFrom(SimpleNDJSONSchema, 'ndjson', invalidNDJSON)).rejects.toThrow();\n    });\n\n    it('should handle schema validation errors', async () => {\n      const invalidNDJSON = `{\"name\": \"John\", \"age\": \"not-a-number\", \"active\": true}`;\n\n      await expect(parseFrom(SimpleNDJSONSchema, 'ndjson', invalidNDJSON)).rejects.toThrow();\n    });\n  });\n\n  describe('NDJSON Streaming Support', () => {\n    it('should support streaming operations', async () => {\n      const ndjsonInput = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n\n      // Should work with streaming enabled\n      await expect(\n        parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput, { streaming: true })\n      ).resolves.toBeDefined();\n      await expect(\n        formatTo(SimpleNDJSONSchema, 'ndjson', { items: [] }, { streaming: true })\n      ).resolves.toBeDefined();\n    });\n\n    it('should handle large NDJSON files efficiently', async () => {\n      // Generate large NDJSON\n      const lines = Array.from({ length: 1000 }, (_, i) =>\n        JSON.stringify({ name: `Person${i}`, age: 20 + i, active: i % 2 === 0 })\n      ).join('\\n');\n\n      const startTime = Date.now();\n      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', lines);\n      const endTime = Date.now();\n\n      expect(result.items).toHaveLength(1000);\n      expect(endTime - startTime).toBeLessThan(1000); // Should complete within 1 second\n    });\n\n    it('should handle streaming with async iterables', async () => {\n      // This test would be expanded when streaming async iterables are implemented\n      const ndjsonInput = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n\n      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput, {\n        streaming: true,\n      });\n      expect(result.items).toHaveLength(2);\n    });\n  });\n\n  describe('NDJSON Metadata', () => {\n    it('should include metadata in parse results', async () => {\n      const ndjsonInput = `{\"name\": \"John\", \"age\": 30, \"active\": true}\n{\"name\": \"Jane\", \"age\": 25, \"active\": false}`;\n\n      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput, {\n        includeProvenance: true,\n      });\n\n      expect(result).toHaveProperty('data');\n      expect(result).toHaveProperty('provenance');\n      expect(result.provenance).toHaveProperty('adapter', 'ndjson');\n      expect(result.provenance).toHaveProperty('sourceFormat', 'ndjson');\n    });\n\n    it('should include metadata in format results', async () => {\n      const data = {\n        items: [{ name: 'John', age: 30, active: true }],\n      };\n\n      const result = await formatTo(SimpleNDJSONSchema, 'ndjson', data, {\n        includeProvenance: true,\n      });\n\n      expect(result).toHaveProperty('data');\n      expect(result).toHaveProperty('provenance');\n      expect(result.provenance).toHaveProperty('adapter', 'ndjson');\n      expect(result.provenance).toHaveProperty('targetFormat', 'ndjson');\n    });\n  });\n\n  describe('NDJSON Edge Cases', () => {\n    it('should handle NDJSON with unicode characters', async () => {\n      const ndjsonInput = `{\"name\": \"José\", \"age\": 30, \"active\": true}\n{\"name\": \"François\", \"age\": 25, \"active\": false}`;\n\n      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput);\n\n      expect(result.items).toHaveLength(2);\n      expect(result.items[0].name).toBe('José');\n      expect(result.items[1].name).toBe('François');\n    });\n\n    it('should handle NDJSON with very long lines', async () => {\n      const longName = 'A'.repeat(10_000);\n      const ndjsonInput = `{\"name\": \"${longName}\", \"age\": 30, \"active\": true}`;\n\n      const result = await parseFrom(SimpleNDJSONSchema, 'ndjson', ndjsonInput);\n\n      expect(result.items).toHaveLength(1);\n      expect(result.items[0].name).toBe(longName);\n    });\n\n    it('should handle NDJSON with deeply nested objects', async () => {\n      const deepNested = {\n        level1: {\n          level2: {\n            level3: {\n              level4: {\n                level5: {\n                  value: 'deep',\n                },\n              },\n            },\n          },\n        },\n      };\n\n      const ndjsonInput = JSON.stringify(deepNested);\n      const schema = z.object({\n        items: z.array(\n          z.object({\n            level1: z.object({\n              level2: z.object({\n                level3: z.object({\n                  level4: z.object({\n                    level5: z.object({\n                      value: z.string(),\n                    }),\n                  }),\n                }),\n              }),\n            }),\n          })\n        ),\n      });\n\n      const result = await parseFrom(schema, 'ndjson', ndjsonInput);\n\n      expect(result.items).toHaveLength(1);\n      expect(result.items[0].level1.level2.level3.level4.level5.value).toBe('deep');\n    });\n  });\n});\n"
        }
    ]
}