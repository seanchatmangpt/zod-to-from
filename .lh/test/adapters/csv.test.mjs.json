{
    "sourceFile": "test/adapters/csv.test.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758645130114,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758645130114,
            "name": "Commit-0",
            "content": "/**\n * CSV Adapter Tests\n * @fileoverview Comprehensive tests for CSV parsing and formatting\n */\n\nimport { beforeEach, describe, expect, it } from 'vitest';\nimport { z } from 'zod';\nimport { convert, formatTo, parseFrom } from '../../src/core/main.mjs';\n\ndescribe('CSV Adapter', () => {\n  const SimpleCSVSchema = z.object({\n    name: z.string(),\n    age: z.number(),\n    active: z.boolean(),\n  });\n\n  const ArrayCSVSchema = z.object({\n    items: z.array(\n      z.object({\n        name: z.string(),\n        age: z.number(),\n        active: z.boolean(),\n      })\n    ),\n  });\n\n  beforeEach(() => {\n    // Ensure clean state for each test\n  });\n\n  describe('CSV Parsing', () => {\n    it('should parse simple CSV with headers', async () => {\n      const csvInput = `name,age,active\nJohn,30,true\nJane,25,false`;\n\n      const result = await parseFrom(ArrayCSVSchema, 'csv', csvInput);\n\n      expect(result.items).toHaveLength(2);\n      expect(result.items[0]).toEqual({\n        name: 'John',\n        age: 30,\n        active: true,\n      });\n      expect(result.items[1]).toEqual({\n        name: 'Jane',\n        age: 25,\n        active: false,\n      });\n    });\n\n    it('should handle CSV with quoted values', async () => {\n      const csvInput = `name,age,active\n\"John Doe\",30,true\n\"Jane, Smith\",25,false`;\n\n      const result = await parseFrom(ArrayCSVSchema, 'csv', csvInput);\n\n      expect(result.items).toHaveLength(2);\n      expect(result.items[0].name).toBe('John Doe');\n      expect(result.items[1].name).toBe('Jane, Smith');\n    });\n\n    it('should handle CSV with empty values', async () => {\n      const csvInput = `name,age,active\nJohn,30,\nJane,,false`;\n\n      const result = await parseFrom(ArrayCSVSchema, 'csv', csvInput);\n\n      expect(result.items).toHaveLength(2);\n      expect(result.items[0].active).toBe('');\n      expect(result.items[1].age).toBe('');\n    });\n\n    it('should handle CSV with custom delimiter', async () => {\n      const csvInput = `name;age;active\nJohn;30;true\nJane;25;false`;\n\n      const result = await parseFrom(ArrayCSVSchema, 'csv', csvInput, {\n        adapter: { delimiter: ';' },\n      });\n\n      expect(result.items).toHaveLength(2);\n      expect(result.items[0]).toEqual({\n        name: 'John',\n        age: 30,\n        active: true,\n      });\n    });\n\n    it('should handle CSV with skip empty lines', async () => {\n      const csvInput = `name,age,active\nJohn,30,true\n\nJane,25,false\n`;\n\n      const result = await parseFrom(ArrayCSVSchema, 'csv', csvInput);\n\n      expect(result.items).toHaveLength(2);\n      expect(result.items[0].name).toBe('John');\n      expect(result.items[1].name).toBe('Jane');\n    });\n\n    it('should throw error for malformed CSV', async () => {\n      const malformedCSV = `name,age,active\nJohn,30,true\nJane,25`; // Missing column\n\n      await expect(parseFrom(ArrayCSVSchema, 'csv', malformedCSV)).rejects.toThrow();\n    });\n\n    it('should handle CSV with different data types', async () => {\n      const csvInput = `name,age,active,score\nJohn,30,true,85.5\nJane,25,false,92.0`;\n\n      const schema = z.object({\n        items: z.array(\n          z.object({\n            name: z.string(),\n            age: z.number(),\n            active: z.boolean(),\n            score: z.number(),\n          })\n        ),\n      });\n\n      const result = await parseFrom(schema, 'csv', csvInput);\n\n      expect(result.items).toHaveLength(2);\n      expect(result.items[0].score).toBe(85.5);\n      expect(result.items[1].score).toBe(92);\n    });\n  });\n\n  describe('CSV Formatting', () => {\n    it('should format array data to CSV', async () => {\n      const data = {\n        items: [\n          { name: 'John', age: 30, active: true },\n          { name: 'Jane', age: 25, active: false },\n        ],\n      };\n\n      const result = await formatTo(ArrayCSVSchema, 'csv', data);\n\n      expect(result).toContain('name,age,active');\n      expect(result).toContain('John,30,true');\n      expect(result).toContain('Jane,25,false');\n    });\n\n    it('should format single object to CSV', async () => {\n      const data = {\n        items: [{ name: 'Single', age: 42, active: true }],\n      };\n\n      const result = await formatTo(ArrayCSVSchema, 'csv', data);\n\n      expect(result).toContain('name,age,active');\n      expect(result).toContain('Single,42,true');\n    });\n\n    it('should handle CSV formatting with custom options', async () => {\n      const data = {\n        items: [\n          { name: 'John', age: 30, active: true },\n          { name: 'Jane', age: 25, active: false },\n        ],\n      };\n\n      const result = await formatTo(ArrayCSVSchema, 'csv', data, {\n        adapter: { delimiter: ';' },\n      });\n\n      expect(result).toContain('name;age;active');\n      expect(result).toContain('John;30;true');\n    });\n\n    it('should handle CSV formatting without headers', async () => {\n      const data = {\n        items: [\n          { name: 'John', age: 30, active: true },\n          { name: 'Jane', age: 25, active: false },\n        ],\n      };\n\n      const result = await formatTo(ArrayCSVSchema, 'csv', data, {\n        adapter: { header: false },\n      });\n\n      expect(result).not.toContain('name,age,active');\n      expect(result).toContain('John,30,true');\n      expect(result).toContain('Jane,25,false');\n    });\n\n    it('should handle empty array formatting', async () => {\n      const data = { items: [] };\n\n      const result = await formatTo(ArrayCSVSchema, 'csv', data);\n\n      expect(result).toContain('name,age,active');\n      expect(result.split('\\n').length).toBe(2); // Header + empty line\n    });\n\n    it('should handle CSV formatting with quoted values', async () => {\n      const data = {\n        items: [\n          { name: 'John, Doe', age: 30, active: true },\n          { name: 'Jane \"Smith\"', age: 25, active: false },\n        ],\n      };\n\n      const result = await formatTo(ArrayCSVSchema, 'csv', data);\n\n      expect(result).toContain('\"John, Doe\"');\n      expect(result).toContain('\"Jane \"\"Smith\"\"\"');\n    });\n  });\n\n  describe('CSV Round-Trip Testing', () => {\n    it('should maintain data integrity through parse-format round-trip', async () => {\n      const originalCSV = `name,age,active\nJohn,30,true\nJane,25,false`;\n\n      // Parse then format\n      const parsed = await parseFrom(ArrayCSVSchema, 'csv', originalCSV);\n      const formatted = await formatTo(ArrayCSVSchema, 'csv', parsed);\n\n      // Parse the formatted result\n      const roundTripParsed = await parseFrom(ArrayCSVSchema, 'csv', formatted);\n\n      expect(roundTripParsed.items).toHaveLength(2);\n      expect(roundTripParsed.items[0]).toEqual({\n        name: 'John',\n        age: 30,\n        active: true,\n      });\n      expect(roundTripParsed.items[1]).toEqual({\n        name: 'Jane',\n        age: 25,\n        active: false,\n      });\n    });\n\n    it('should handle round-trip with custom delimiter', async () => {\n      const originalCSV = `name;age;active\nJohn;30;true\nJane;25;false`;\n\n      const options = { adapter: { delimiter: ';' } };\n\n      // Parse then format\n      const parsed = await parseFrom(ArrayCSVSchema, 'csv', originalCSV, options);\n      const formatted = await formatTo(ArrayCSVSchema, 'csv', parsed, options);\n\n      // Parse the formatted result\n      const roundTripParsed = await parseFrom(ArrayCSVSchema, 'csv', formatted, options);\n\n      expect(roundTripParsed.items).toHaveLength(2);\n      expect(roundTripParsed.items[0].name).toBe('John');\n      expect(roundTripParsed.items[1].name).toBe('Jane');\n    });\n\n    it('should handle round-trip with quoted values', async () => {\n      const originalCSV = `name,age,active\n\"John, Doe\",30,true\n\"Jane \"\"Smith\"\"\",25,false`;\n\n      // Parse then format\n      const parsed = await parseFrom(ArrayCSVSchema, 'csv', originalCSV);\n      const formatted = await formatTo(ArrayCSVSchema, 'csv', parsed);\n\n      // Parse the formatted result\n      const roundTripParsed = await parseFrom(ArrayCSVSchema, 'csv', formatted);\n\n      expect(roundTripParsed.items).toHaveLength(2);\n      expect(roundTripParsed.items[0].name).toBe('John, Doe');\n      expect(roundTripParsed.items[1].name).toBe('Jane \"Smith\"');\n    });\n  });\n\n  describe('CSV Conversion', () => {\n    it('should convert CSV to JSON', async () => {\n      const csvInput = `name,age,active\nJohn,30,true\nJane,25,false`;\n\n      const result = await convert(ArrayCSVSchema, { from: 'csv', to: 'json' }, csvInput);\n\n      const parsedResult = JSON.parse(result);\n      expect(parsedResult.items).toHaveLength(2);\n      expect(parsedResult.items[0]).toEqual({\n        name: 'John',\n        age: 30,\n        active: true,\n      });\n    });\n\n    it('should convert JSON to CSV', async () => {\n      const jsonInput = JSON.stringify({\n        items: [\n          { name: 'John', age: 30, active: true },\n          { name: 'Jane', age: 25, active: false },\n        ],\n      });\n\n      const result = await convert(ArrayCSVSchema, { from: 'json', to: 'csv' }, jsonInput);\n\n      expect(result).toContain('name,age,active');\n      expect(result).toContain('John,30,true');\n      expect(result).toContain('Jane,25,false');\n    });\n\n    it('should handle CSV to CSV conversion (round-trip)', async () => {\n      const csvInput = `name,age,active\nJohn,30,true\nJane,25,false`;\n\n      const result = await convert(ArrayCSVSchema, { from: 'csv', to: 'csv' }, csvInput);\n\n      expect(result).toContain('name,age,active');\n      expect(result).toContain('John,30,true');\n      expect(result).toContain('Jane,25,false');\n    });\n  });\n\n  describe('CSV Error Handling', () => {\n    it('should handle empty CSV input', async () => {\n      await expect(parseFrom(ArrayCSVSchema, 'csv', '')).rejects.toThrow();\n    });\n\n    it('should handle CSV with only headers', async () => {\n      const csvInput = 'name,age,active';\n\n      const result = await parseFrom(ArrayCSVSchema, 'csv', csvInput);\n\n      expect(result.items).toHaveLength(0);\n    });\n\n    it('should handle CSV with inconsistent columns', async () => {\n      const csvInput = `name,age,active\nJohn,30,true\nJane,25`; // Missing active column\n\n      await expect(parseFrom(ArrayCSVSchema, 'csv', csvInput)).rejects.toThrow();\n    });\n\n    it('should handle CSV with invalid data types', async () => {\n      const csvInput = `name,age,active\nJohn,not-a-number,true`;\n\n      await expect(parseFrom(ArrayCSVSchema, 'csv', csvInput)).rejects.toThrow();\n    });\n\n    it('should handle malformed CSV with unclosed quotes', async () => {\n      const csvInput = `name,age,active\n\"John,30,true\nJane,25,false`;\n\n      await expect(parseFrom(ArrayCSVSchema, 'csv', csvInput)).rejects.toThrow();\n    });\n  });\n\n  describe('CSV Streaming Support', () => {\n    it('should support streaming operations', async () => {\n      const csvInput = `name,age,active\nJohn,30,true\nJane,25,false`;\n\n      // Should work with streaming enabled\n      await expect(\n        parseFrom(ArrayCSVSchema, 'csv', csvInput, { streaming: true })\n      ).resolves.toBeDefined();\n      await expect(\n        formatTo(ArrayCSVSchema, 'csv', { items: [] }, { streaming: true })\n      ).resolves.toBeDefined();\n    });\n\n    it('should handle large CSV files efficiently', async () => {\n      // Generate large CSV\n      const headers = 'name,age,active\\n';\n      const rows = Array.from(\n        { length: 1000 },\n        (_, i) => `Person${i},${20 + i},${i % 2 === 0}`\n      ).join('\\n');\n      const largeCSV = headers + rows;\n\n      const startTime = Date.now();\n      const result = await parseFrom(ArrayCSVSchema, 'csv', largeCSV);\n      const endTime = Date.now();\n\n      expect(result.items).toHaveLength(1000);\n      expect(endTime - startTime).toBeLessThan(1000); // Should complete within 1 second\n    });\n  });\n\n  describe('CSV Metadata', () => {\n    it('should include metadata in parse results', async () => {\n      const csvInput = `name,age,active\nJohn,30,true\nJane,25,false`;\n\n      const result = await parseFrom(ArrayCSVSchema, 'csv', csvInput, { includeProvenance: true });\n\n      expect(result).toHaveProperty('data');\n      expect(result).toHaveProperty('provenance');\n      expect(result.provenance).toHaveProperty('adapter', 'csv');\n      expect(result.provenance).toHaveProperty('sourceFormat', 'csv');\n    });\n\n    it('should include metadata in format results', async () => {\n      const data = {\n        items: [{ name: 'John', age: 30, active: true }],\n      };\n\n      const result = await formatTo(ArrayCSVSchema, 'csv', data, { includeProvenance: true });\n\n      expect(result).toHaveProperty('data');\n      expect(result).toHaveProperty('provenance');\n      expect(result.provenance).toHaveProperty('adapter', 'csv');\n      expect(result.provenance).toHaveProperty('targetFormat', 'csv');\n    });\n  });\n});\n"
        }
    ]
}