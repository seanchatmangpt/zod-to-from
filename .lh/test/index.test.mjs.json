{
    "sourceFile": "test/index.test.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1758643834023,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758645130127,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,10 +53,14 @@\n     const initialAdapters = listAdapters();\n     expect(initialAdapters).toContain('json');\n \n     registerAdapter('test', {\n-      parse: input => ({ test: input }),\n-      format: data => JSON.stringify(data),\n+      async parse(input) {\n+        return { data: { test: input }, metadata: {} };\n+      },\n+      async format(data) {\n+        return { data: JSON.stringify(data), metadata: {} };\n+      },\n     });\n \n     const updatedAdapters = listAdapters();\n     expect(updatedAdapters).toContain('test');\n@@ -88,16 +92,16 @@\n     expect(result.provenance).toHaveProperty('version');\n   });\n \n   it('should provide deterministic output when requested', async () => {\n-    const data = { name: 'Test', age: 25, active: true, c: 3, a: 1, b: 2 };\n+    const data = { name: 'Test', age: 25, active: true };\n     const result1 = await formatTo(TestSchema, 'json', data, { deterministic: true });\n     const result2 = await formatTo(TestSchema, 'json', data, { deterministic: true });\n \n     expect(result1).toBe(result2);\n-    expect(result1).toContain('\"a\": 1');\n-    expect(result1).toContain('\"b\": 2');\n-    expect(result1).toContain('\"c\": 3');\n+    expect(result1).toContain('\"name\": \"Test\"');\n+    expect(result1).toContain('\"age\": 25');\n+    expect(result1).toContain('\"active\": true');\n   });\n \n   it('should get adapter information', () => {\n     const info = getAdapterInfo('json');\n@@ -167,8 +171,8 @@\n     await expect(parseFrom(TestSchema, 'json', input, { streaming: false })).resolves.toBeDefined();\n \n     // Should throw for streaming requests on non-streaming adapters\n     await expect(parseFrom(TestSchema, 'json', input, { streaming: true })).rejects.toThrow(\n-      'Adapter json does not support streaming'\n+      \"Adapter 'json' does not support streaming\"\n     );\n   });\n });\n"
                }
            ],
            "date": 1758643834023,
            "name": "Commit-0",
            "content": "import { describe, expect, it } from 'vitest';\nimport { z } from 'zod';\nimport {\n  adapterSupports,\n  convert,\n  createPackManifest,\n  formatTo,\n  getAdapterInfo,\n  listAdapters,\n  listAdaptersWithInfo,\n  parseFrom,\n  registerAdapter,\n  registerPack,\n} from '../src/core/index.mjs';\n\ndescribe('zod-to-from', () => {\n  const TestSchema = z.object({\n    name: z.string(),\n    age: z.number(),\n    active: z.boolean(),\n  });\n\n  it('should parse JSON input', async () => {\n    const input = '{\"name\": \"John\", \"age\": 30, \"active\": true}';\n    const result = await parseFrom(TestSchema, 'json', input);\n\n    expect(result).toEqual({\n      name: 'John',\n      age: 30,\n      active: true,\n    });\n  });\n\n  it('should format data to JSON', async () => {\n    const data = { name: 'Jane', age: 25, active: false };\n    const result = await formatTo(TestSchema, 'json', data);\n\n    expect(result).toContain('\"name\": \"Jane\"');\n    expect(result).toContain('\"age\": 25');\n    expect(result).toContain('\"active\": false');\n  });\n\n  it('should convert between formats', async () => {\n    const input = '{\"name\": \"Bob\", \"age\": 35, \"active\": true}';\n    const result = await convert(TestSchema, { from: 'json', to: 'json' }, input);\n\n    expect(result).toContain('\"name\": \"Bob\"');\n    expect(result).toContain('\"age\": 35');\n    expect(result).toContain('\"active\": true');\n  });\n\n  it('should register and list adapters', () => {\n    const initialAdapters = listAdapters();\n    expect(initialAdapters).toContain('json');\n\n    registerAdapter('test', {\n      parse: input => ({ test: input }),\n      format: data => JSON.stringify(data),\n    });\n\n    const updatedAdapters = listAdapters();\n    expect(updatedAdapters).toContain('test');\n  });\n\n  it('should throw error for unknown format', async () => {\n    const input = '{\"name\": \"Test\"}';\n\n    await expect(parseFrom(TestSchema, 'unknown-format', input)).rejects.toThrow(\n      'No adapter found for format: unknown-format'\n    );\n  });\n\n  it('should validate data against schema', async () => {\n    const invalidData = { name: 'Test', age: 'not-a-number' };\n\n    await expect(formatTo(TestSchema, 'json', invalidData)).rejects.toThrow();\n  });\n\n  it('should include provenance metadata when requested', async () => {\n    const input = '{\"name\": \"John\", \"age\": 30, \"active\": true}';\n    const result = await parseFrom(TestSchema, 'json', input, { includeProvenance: true });\n\n    expect(result).toHaveProperty('data');\n    expect(result).toHaveProperty('provenance');\n    expect(result.provenance).toHaveProperty('timestamp');\n    expect(result.provenance).toHaveProperty('sourceFormat', 'json');\n    expect(result.provenance).toHaveProperty('adapter', 'json');\n    expect(result.provenance).toHaveProperty('version');\n  });\n\n  it('should provide deterministic output when requested', async () => {\n    const data = { name: 'Test', age: 25, active: true, c: 3, a: 1, b: 2 };\n    const result1 = await formatTo(TestSchema, 'json', data, { deterministic: true });\n    const result2 = await formatTo(TestSchema, 'json', data, { deterministic: true });\n\n    expect(result1).toBe(result2);\n    expect(result1).toContain('\"a\": 1');\n    expect(result1).toContain('\"b\": 2');\n    expect(result1).toContain('\"c\": 3');\n  });\n\n  it('should get adapter information', () => {\n    const info = getAdapterInfo('json');\n\n    expect(info).toHaveProperty('name', 'json');\n    expect(info).toHaveProperty('version');\n    expect(info).toHaveProperty('supportsStreaming', false);\n    expect(info).toHaveProperty('isAI', false);\n  });\n\n  it('should list adapters with information', () => {\n    const adapters = listAdaptersWithInfo();\n\n    expect(adapters.length).toBeGreaterThanOrEqual(1);\n    const jsonAdapter = adapters.find(a => a.name === 'json');\n    expect(jsonAdapter).toHaveProperty('name', 'json');\n    expect(jsonAdapter).toHaveProperty('version');\n  });\n\n  it('should check adapter feature support', () => {\n    expect(adapterSupports('json', 'streaming')).toBe(false);\n    expect(adapterSupports('json', 'ai')).toBe(false);\n    expect(adapterSupports('nonexistent', 'streaming')).toBe(false);\n  });\n\n  it('should create pack manifests', () => {\n    const manifest = createPackManifest('test-pack', ['yaml', 'toml'], {\n      version: '2.0.0',\n      description: 'Test pack for YAML and TOML',\n    });\n\n    expect(manifest).toHaveProperty('name', 'test-pack');\n    expect(manifest).toHaveProperty('version', '2.0.0');\n    expect(manifest).toHaveProperty('formats', ['yaml', 'toml']);\n    expect(manifest).toHaveProperty('description', 'Test pack for YAML and TOML');\n  });\n\n  it('should register packs', () => {\n    const manifest = createPackManifest('test-pack', ['yaml'], {\n      version: '1.0.0',\n    });\n\n    const testAdapters = {\n      yaml: {\n        async parse(input) {\n          return { data: { test: 'yaml' }, metadata: {} };\n        },\n        async format(data) {\n          return { data: 'yaml: test', metadata: {} };\n        },\n        supportsStreaming: true,\n        isAI: false,\n      },\n    };\n\n    registerPack(manifest, testAdapters);\n\n    expect(listAdapters()).toContain('yaml');\n    expect(getAdapterInfo('yaml')).toHaveProperty('supportsStreaming', true);\n  });\n\n  it('should handle streaming requests', async () => {\n    // Test that streaming is properly handled\n    const input = '{\"name\": \"Test\", \"age\": 25, \"active\": true}';\n\n    // Should work for non-streaming adapters\n    await expect(parseFrom(TestSchema, 'json', input, { streaming: false })).resolves.toBeDefined();\n\n    // Should throw for streaming requests on non-streaming adapters\n    await expect(parseFrom(TestSchema, 'json', input, { streaming: true })).rejects.toThrow(\n      'Adapter json does not support streaming'\n    );\n  });\n});\n"
        }
    ]
}