{
    "sourceFile": "test/core/main.test.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758645130112,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758645130112,
            "name": "Commit-0",
            "content": "/**\n * Core API Tests - Main ZTF functions\n * @fileoverview Comprehensive tests for parseFrom, formatTo, and convert functions\n */\n\nimport { afterEach, beforeEach, describe, expect, it } from 'vitest';\nimport { z } from 'zod';\nimport { convert, formatTo, parseFrom } from '../../src/core/main.mjs';\nimport { registerAdapter } from '../../src/core/registry.mjs';\n\ndescribe('Core API - Main Functions', () => {\n  // Test schemas for different data types\n  const SimpleSchema = z.object({\n    name: z.string(),\n    age: z.number(),\n    active: z.boolean(),\n  });\n\n  const ComplexSchema = z.object({\n    id: z.string().uuid(),\n    metadata: z.object({\n      tags: z.array(z.string()),\n      score: z.number().min(0).max(100),\n    }),\n    nested: z.object({\n      value: z.string(),\n      optional: z.string().optional(),\n    }),\n  });\n\n  const ArraySchema = z.object({\n    items: z.array(\n      z.object({\n        id: z.number(),\n        name: z.string(),\n      })\n    ),\n    count: z.number(),\n  });\n\n  beforeEach(() => {\n    // Ensure clean state for each test\n  });\n\n  afterEach(() => {\n    // Cleanup if needed\n  });\n\n  describe('parseFrom', () => {\n    it('should parse valid JSON input', async () => {\n      const input = '{\"name\": \"John\", \"age\": 30, \"active\": true}';\n      const result = await parseFrom(SimpleSchema, 'json', input);\n\n      expect(result).toEqual({\n        name: 'John',\n        age: 30,\n        active: true,\n      });\n    });\n\n    it('should throw error for unknown format', async () => {\n      const input = '{\"name\": \"Test\"}';\n\n      await expect(parseFrom(SimpleSchema, 'unknown-format', input)).rejects.toThrow(\n        'No adapter found for format: unknown-format'\n      );\n    });\n\n    it('should validate data against schema', async () => {\n      const invalidInput = '{\"name\": \"Test\", \"age\": \"not-a-number\"}';\n\n      await expect(parseFrom(SimpleSchema, 'json', invalidInput)).rejects.toThrow();\n    });\n\n    it('should include provenance metadata when requested', async () => {\n      const input = '{\"name\": \"John\", \"age\": 30, \"active\": true}';\n      const result = await parseFrom(SimpleSchema, 'json', input, { includeProvenance: true });\n\n      expect(result).toHaveProperty('data');\n      expect(result).toHaveProperty('provenance');\n      expect(result.provenance).toHaveProperty('timestamp');\n      expect(result.provenance).toHaveProperty('sourceFormat', 'json');\n      expect(result.provenance).toHaveProperty('adapter', 'json');\n      expect(result.provenance).toHaveProperty('version');\n      expect(result.provenance).toHaveProperty('schemaHash');\n    });\n\n    it('should handle streaming requests correctly', async () => {\n      const input = '{\"name\": \"Test\", \"age\": 25, \"active\": true}';\n\n      // Should work for non-streaming adapters\n      await expect(\n        parseFrom(SimpleSchema, 'json', input, { streaming: false })\n      ).resolves.toBeDefined();\n\n      // Should throw for streaming requests on non-streaming adapters\n      await expect(parseFrom(SimpleSchema, 'json', input, { streaming: true })).rejects.toThrow(\n        \"Adapter 'json' does not support streaming\"\n      );\n    });\n\n    it('should pass adapter options correctly', async () => {\n      // Register a test adapter that tracks options\n      let receivedOptions = undefined;\n      registerAdapter('test-options', {\n        async parse(input, opts = {}) {\n          receivedOptions = opts;\n          return { data: JSON.parse(input), metadata: {} };\n        },\n        async format(data, opts = {}) {\n          return { data: JSON.stringify(data), metadata: {} };\n        },\n        supportsStreaming: false,\n        isAI: false,\n      });\n\n      const input = '{\"name\": \"Test\"}';\n      const customOptions = { custom: 'value', nested: { option: true } };\n\n      await parseFrom(SimpleSchema, 'test-options', input, { adapter: customOptions });\n\n      expect(receivedOptions).toEqual(customOptions);\n    });\n\n    it('should handle complex nested data structures', async () => {\n      const complexData = {\n        id: '123e4567-e89b-12d3-a456-426614174000',\n        metadata: {\n          tags: ['important', 'test'],\n          score: 85,\n        },\n        nested: {\n          value: 'test-value',\n          optional: 'optional-value',\n        },\n      };\n\n      const input = JSON.stringify(complexData);\n      const result = await parseFrom(ComplexSchema, 'json', input);\n\n      expect(result).toEqual(complexData);\n    });\n\n    it('should handle array data structures', async () => {\n      const arrayData = {\n        items: [\n          { id: 1, name: 'Item 1' },\n          { id: 2, name: 'Item 2' },\n        ],\n        count: 2,\n      };\n\n      const input = JSON.stringify(arrayData);\n      const result = await parseFrom(ArraySchema, 'json', input);\n\n      expect(result).toEqual(arrayData);\n    });\n  });\n\n  describe('formatTo', () => {\n    it('should format data to JSON', async () => {\n      const data = { name: 'Jane', age: 25, active: false };\n      const result = await formatTo(SimpleSchema, 'json', data);\n\n      expect(result).toContain('\"name\": \"Jane\"');\n      expect(result).toContain('\"age\": 25');\n      expect(result).toContain('\"active\": false');\n    });\n\n    it('should throw error for unknown format', async () => {\n      const data = { name: 'Test' };\n\n      await expect(formatTo(SimpleSchema, 'unknown-format', data)).rejects.toThrow(\n        'No adapter found for format: unknown-format'\n      );\n    });\n\n    it('should validate data against schema before formatting', async () => {\n      const invalidData = { name: 'Test', age: 'not-a-number' };\n\n      await expect(formatTo(SimpleSchema, 'json', invalidData)).rejects.toThrow();\n    });\n\n    it('should provide deterministic output when requested', async () => {\n      const data = { name: 'Test', age: 25, active: true };\n      const result1 = await formatTo(SimpleSchema, 'json', data, { deterministic: true });\n      const result2 = await formatTo(SimpleSchema, 'json', data, { deterministic: true });\n\n      expect(result1).toBe(result2);\n      expect(result1).toContain('\"name\": \"Test\"');\n      expect(result1).toContain('\"age\": 25');\n      expect(result1).toContain('\"active\": true');\n    });\n\n    it('should include provenance metadata when requested', async () => {\n      const data = { name: 'John', age: 30, active: true };\n      const result = await formatTo(SimpleSchema, 'json', data, { includeProvenance: true });\n\n      expect(result).toHaveProperty('data');\n      expect(result).toHaveProperty('provenance');\n      expect(result.provenance).toHaveProperty('timestamp');\n      expect(result.provenance).toHaveProperty('targetFormat', 'json');\n      expect(result.provenance).toHaveProperty('adapter', 'json');\n      expect(result.provenance).toHaveProperty('version');\n      expect(result.provenance).toHaveProperty('schemaHash');\n    });\n\n    it('should handle streaming requests correctly', async () => {\n      const data = { name: 'Test', age: 25, active: true };\n\n      // Should work for non-streaming adapters\n      await expect(\n        formatTo(SimpleSchema, 'json', data, { streaming: false })\n      ).resolves.toBeDefined();\n\n      // Should throw for streaming requests on non-streaming adapters\n      await expect(formatTo(SimpleSchema, 'json', data, { streaming: true })).rejects.toThrow(\n        \"Adapter 'json' does not support streaming\"\n      );\n    });\n\n    it('should pass adapter options correctly', async () => {\n      // Register a test adapter that tracks options\n      let receivedOptions = undefined;\n      registerAdapter('test-format-options', {\n        async parse(input, opts = {}) {\n          return { data: JSON.parse(input), metadata: {} };\n        },\n        async format(data, opts = {}) {\n          receivedOptions = opts;\n          return { data: JSON.stringify(data), metadata: {} };\n        },\n        supportsStreaming: false,\n        isAI: false,\n      });\n\n      const data = { name: 'Test' };\n      const customOptions = { indent: 4, sortKeys: true };\n\n      await formatTo(SimpleSchema, 'test-format-options', data, { adapter: customOptions });\n\n      expect(receivedOptions).toEqual(customOptions);\n    });\n  });\n\n  describe('convert', () => {\n    it('should convert between formats', async () => {\n      const input = '{\"name\": \"Bob\", \"age\": 35, \"active\": true}';\n      const result = await convert(SimpleSchema, { from: 'json', to: 'json' }, input);\n\n      expect(result).toContain('\"name\": \"Bob\"');\n      expect(result).toContain('\"age\": 35');\n      expect(result).toContain('\"active\": true');\n    });\n\n    it('should handle provenance in conversion', async () => {\n      const input = '{\"name\": \"Test\", \"age\": 25, \"active\": true}';\n      const result = await convert(SimpleSchema, { from: 'json', to: 'json' }, input, {\n        includeProvenance: true,\n      });\n\n      expect(result).toHaveProperty('data');\n      expect(result).toHaveProperty('provenance');\n      expect(result.provenance).toHaveProperty('sourceFormat', 'json');\n      expect(result.provenance).toHaveProperty('targetFormat', 'json');\n    });\n\n    it('should throw error for unknown source format', async () => {\n      const input = '{\"name\": \"Test\"}';\n\n      await expect(convert(SimpleSchema, { from: 'unknown', to: 'json' }, input)).rejects.toThrow(\n        'No adapter found for format: unknown'\n      );\n    });\n\n    it('should throw error for unknown target format', async () => {\n      const input = '{\"name\": \"Test\"}';\n\n      await expect(convert(SimpleSchema, { from: 'json', to: 'unknown' }, input)).rejects.toThrow(\n        'No adapter found for format: unknown'\n      );\n    });\n\n    it('should validate data at both parse and format stages', async () => {\n      const invalidInput = '{\"name\": \"Test\", \"age\": \"not-a-number\"}';\n\n      await expect(\n        convert(SimpleSchema, { from: 'json', to: 'json' }, invalidInput)\n      ).rejects.toThrow();\n    });\n\n    it('should handle complex conversion workflows', async () => {\n      const complexData = {\n        id: '123e4567-e89b-12d3-a456-426614174000',\n        metadata: {\n          tags: ['conversion', 'test'],\n          score: 90,\n        },\n        nested: {\n          value: 'conversion-test',\n        },\n      };\n\n      const input = JSON.stringify(complexData);\n      const result = await convert(ComplexSchema, { from: 'json', to: 'json' }, input);\n\n      const parsedResult = JSON.parse(result);\n      expect(parsedResult).toEqual(complexData);\n    });\n  });\n\n  describe('Round-Trip Invariant Testing', () => {\n    it('should maintain data integrity through parse-format round-trip', async () => {\n      const originalData = { name: 'RoundTrip', age: 42, active: true };\n      const input = JSON.stringify(originalData);\n\n      // Parse then format\n      const parsed = await parseFrom(SimpleSchema, 'json', input);\n      const formatted = await formatTo(SimpleSchema, 'json', parsed);\n      const roundTripParsed = JSON.parse(formatted);\n\n      expect(roundTripParsed).toEqual(originalData);\n    });\n\n    it('should maintain data integrity through convert round-trip', async () => {\n      const originalData = { name: 'ConvertRoundTrip', age: 33, active: false };\n      const input = JSON.stringify(originalData);\n\n      // Convert json -> json\n      const converted = await convert(SimpleSchema, { from: 'json', to: 'json' }, input);\n      const roundTripConverted = await convert(\n        SimpleSchema,\n        { from: 'json', to: 'json' },\n        converted\n      );\n\n      expect(JSON.parse(roundTripConverted)).toEqual(originalData);\n    });\n\n    it('should handle complex nested structures in round-trip', async () => {\n      const originalData = {\n        id: '123e4567-e89b-12d3-a456-426614174000',\n        metadata: {\n          tags: ['roundtrip', 'complex'],\n          score: 75,\n        },\n        nested: {\n          value: 'roundtrip-test',\n          optional: 'present',\n        },\n      };\n\n      const input = JSON.stringify(originalData);\n\n      // Parse then format\n      const parsed = await parseFrom(ComplexSchema, 'json', input);\n      const formatted = await formatTo(ComplexSchema, 'json', parsed);\n      const roundTripParsed = JSON.parse(formatted);\n\n      expect(roundTripParsed).toEqual(originalData);\n    });\n  });\n\n  describe('Error Handling and Edge Cases', () => {\n    it('should handle empty input gracefully', async () => {\n      await expect(parseFrom(SimpleSchema, 'json', '')).rejects.toThrow();\n    });\n\n    it('should handle null/undefined data gracefully', async () => {\n      await expect(formatTo(SimpleSchema, 'json', undefined)).rejects.toThrow();\n      await expect(formatTo(SimpleSchema, 'json', undefined)).rejects.toThrow();\n    });\n\n    it('should handle malformed JSON input', async () => {\n      const malformedInput = '{\"name\": \"Test\", \"age\": 25, \"active\": true'; // Missing closing brace\n\n      await expect(parseFrom(SimpleSchema, 'json', malformedInput)).rejects.toThrow();\n    });\n\n    it('should handle schema validation errors with detailed messages', async () => {\n      const invalidData = { name: 'Test', age: -5, active: true }; // Negative age should fail if schema has min constraint\n\n      const schemaWithConstraints = z.object({\n        name: z.string(),\n        age: z.number().min(0),\n        active: z.boolean(),\n      });\n\n      await expect(formatTo(schemaWithConstraints, 'json', invalidData)).rejects.toThrow();\n    });\n\n    it('should handle very large data structures', async () => {\n      const largeData = {\n        name: 'LargeTest',\n        age: 30,\n        active: true,\n        largeArray: Array.from({ length: 1000 }, (_, i) => ({ id: i, value: `item-${i}` })),\n      };\n\n      const largeSchema = z.object({\n        name: z.string(),\n        age: z.number(),\n        active: z.boolean(),\n        largeArray: z.array(\n          z.object({\n            id: z.number(),\n            value: z.string(),\n          })\n        ),\n      });\n\n      const input = JSON.stringify(largeData);\n      const result = await parseFrom(largeSchema, 'json', input);\n\n      expect(result.largeArray).toHaveLength(1000);\n      expect(result.largeArray[0]).toEqual({ id: 0, value: 'item-0' });\n    });\n  });\n});\n"
        }
    ]
}