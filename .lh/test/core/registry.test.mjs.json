{
    "sourceFile": "test/core/registry.test.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1758645130117,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758645941515,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,9 +15,9 @@\n   listAdaptersWithInfo,\n   registerAdapter,\n   registerPack,\n   simpleHash,\n-} from '../../src/core/registry.mjs';\n+} from '../setup.mjs';\n \n describe('Core API - Registry Functions', () => {\n   beforeEach(() => {\n     // Clean state for each test\n@@ -435,9 +435,12 @@\n         name: 'test',\n       };\n \n       const result = deterministicStringify(obj);\n-      expect(result).toContain('\"items\": [3, 1, 2]');\n+      expect(result).toContain('\"items\": [');\n+      expect(result).toContain('3');\n+      expect(result).toContain('1');\n+      expect(result).toContain('2');\n       expect(result).toContain('\"name\": \"test\"');\n     });\n \n     it('should handle null and undefined values', () => {\n@@ -447,12 +450,12 @@\n         normalValue: 'test',\n       };\n \n       const result = deterministicStringify(obj);\n-      expect(result).toContain('\"nullValue\": undefined');\n-      expect(result).toContain('\"normalValue\": \"test\"');\n       // undefined values should be omitted\n+      expect(result).not.toContain('nullValue');\n       expect(result).not.toContain('undefinedValue');\n+      expect(result).toContain('\"normalValue\": \"test\"');\n     });\n   });\n \n   describe('Error Handling', () => {\n"
                }
            ],
            "date": 1758645130117,
            "name": "Commit-0",
            "content": "/**\n * Registry Tests - Adapter registration and management\n * @fileoverview Comprehensive tests for the adapter registry system\n */\n\nimport { afterEach, beforeEach, describe, expect, it } from 'vitest';\nimport {\n  adapterSupports,\n  createPackManifest,\n  createProvenance,\n  deterministicStringify,\n  getAdapter,\n  getAdapterInfo,\n  listAdapters,\n  listAdaptersWithInfo,\n  registerAdapter,\n  registerPack,\n  simpleHash,\n} from '../../src/core/registry.mjs';\n\ndescribe('Core API - Registry Functions', () => {\n  beforeEach(() => {\n    // Clean state for each test\n  });\n\n  afterEach(() => {\n    // Cleanup if needed\n  });\n\n  describe('Adapter Registration', () => {\n    it('should register a new adapter', () => {\n      const testAdapter = {\n        async parse(input, opts = {}) {\n          return { data: { test: input }, metadata: {} };\n        },\n        async format(data, opts = {}) {\n          return { data: JSON.stringify(data), metadata: {} };\n        },\n        supportsStreaming: false,\n        isAI: false,\n        version: '1.0.0',\n      };\n\n      registerAdapter('test-adapter', testAdapter);\n      const retrieved = getAdapter('test-adapter');\n\n      expect(retrieved).toBe(testAdapter);\n    });\n\n    it('should overwrite existing adapter with same name', () => {\n      const adapter1 = {\n        async parse(input) {\n          return { data: 'adapter1', metadata: {} };\n        },\n        async format(data) {\n          return { data: 'adapter1', metadata: {} };\n        },\n        version: '1.0.0',\n      };\n\n      const adapter2 = {\n        async parse(input) {\n          return { data: 'adapter2', metadata: {} };\n        },\n        async format(data) {\n          return { data: 'adapter2', metadata: {} };\n        },\n        version: '2.0.0',\n      };\n\n      registerAdapter('overwrite-test', adapter1);\n      expect(getAdapter('overwrite-test')).toBe(adapter1);\n\n      registerAdapter('overwrite-test', adapter2);\n      expect(getAdapter('overwrite-test')).toBe(adapter2);\n    });\n\n    it('should return undefined for non-existent adapter', () => {\n      const result = getAdapter('non-existent');\n      expect(result).toBeUndefined();\n    });\n  });\n\n  describe('Adapter Listing', () => {\n    it('should list all registered adapters', () => {\n      const initialAdapters = listAdapters();\n      expect(Array.isArray(initialAdapters)).toBe(true);\n      expect(initialAdapters).toContain('json'); // Built-in adapter\n\n      // Register a test adapter\n      registerAdapter('list-test', {\n        async parse(input) {\n          return { data: input, metadata: {} };\n        },\n        async format(data) {\n          return { data: JSON.stringify(data), metadata: {} };\n        },\n      });\n\n      const updatedAdapters = listAdapters();\n      expect(updatedAdapters).toContain('list-test');\n      expect(updatedAdapters.length).toBe(initialAdapters.length + 1);\n    });\n\n    it('should return unique adapter names', () => {\n      const adapters = listAdapters();\n      const uniqueAdapters = [...new Set(adapters)];\n      expect(adapters.length).toBe(uniqueAdapters.length);\n    });\n  });\n\n  describe('Adapter Information', () => {\n    it('should get adapter information', () => {\n      const testAdapter = {\n        async parse(input) {\n          return { data: input, metadata: {} };\n        },\n        async format(data) {\n          return { data: JSON.stringify(data), metadata: {} };\n        },\n        supportsStreaming: true,\n        isAI: true,\n        version: '2.1.0',\n      };\n\n      registerAdapter('info-test', testAdapter);\n      const info = getAdapterInfo('info-test');\n\n      expect(info).toEqual({\n        name: 'info-test',\n        version: '2.1.0',\n        supportsStreaming: true,\n        isAI: true,\n        hasParse: true,\n        hasFormat: true,\n      });\n    });\n\n    it('should return undefined for non-existent adapter info', () => {\n      const info = getAdapterInfo('non-existent');\n      expect(info).toBeUndefined();\n    });\n\n    it('should handle adapters with missing optional properties', () => {\n      const minimalAdapter = {\n        async parse(input) {\n          return { data: input, metadata: {} };\n        },\n        async format(data) {\n          return { data: JSON.stringify(data), metadata: {} };\n        },\n      };\n\n      registerAdapter('minimal-test', minimalAdapter);\n      const info = getAdapterInfo('minimal-test');\n\n      expect(info).toEqual({\n        name: 'minimal-test',\n        version: '1.0.0', // Default version\n        supportsStreaming: false, // Default value\n        isAI: false, // Default value\n        hasParse: true,\n        hasFormat: true,\n      });\n    });\n\n    it('should list all adapters with information', () => {\n      const adaptersWithInfo = listAdaptersWithInfo();\n      expect(Array.isArray(adaptersWithInfo)).toBe(true);\n      expect(adaptersWithInfo.length).toBeGreaterThan(0);\n\n      // Check that all returned adapters have required properties\n      for (const adapter of adaptersWithInfo) {\n        expect(adapter).toHaveProperty('name');\n        expect(adapter).toHaveProperty('version');\n        expect(adapter).toHaveProperty('supportsStreaming');\n        expect(adapter).toHaveProperty('isAI');\n        expect(adapter).toHaveProperty('hasParse');\n        expect(adapter).toHaveProperty('hasFormat');\n      }\n\n      // Check that built-in json adapter is included\n      const jsonAdapter = adaptersWithInfo.find(a => a.name === 'json');\n      expect(jsonAdapter).toBeDefined();\n      expect(jsonAdapter.hasParse).toBe(true);\n      expect(jsonAdapter.hasFormat).toBe(true);\n    });\n  });\n\n  describe('Feature Support Checking', () => {\n    it('should check streaming support', () => {\n      const streamingAdapter = {\n        async parse(input) {\n          return { data: input, metadata: {} };\n        },\n        async format(data) {\n          return { data: JSON.stringify(data), metadata: {} };\n        },\n        supportsStreaming: true,\n      };\n\n      const nonStreamingAdapter = {\n        async parse(input) {\n          return { data: input, metadata: {} };\n        },\n        async format(data) {\n          return { data: JSON.stringify(data), metadata: {} };\n        },\n        supportsStreaming: false,\n      };\n\n      registerAdapter('streaming-test', streamingAdapter);\n      registerAdapter('non-streaming-test', nonStreamingAdapter);\n\n      expect(adapterSupports('streaming-test', 'streaming')).toBe(true);\n      expect(adapterSupports('non-streaming-test', 'streaming')).toBe(false);\n      expect(adapterSupports('non-existent', 'streaming')).toBe(false);\n    });\n\n    it('should check AI support', () => {\n      const aiAdapter = {\n        async parse(input) {\n          return { data: input, metadata: {} };\n        },\n        async format(data) {\n          return { data: JSON.stringify(data), metadata: {} };\n        },\n        isAI: true,\n      };\n\n      const nonAIAdapter = {\n        async parse(input) {\n          return { data: input, metadata: {} };\n        },\n        async format(data) {\n          return { data: JSON.stringify(data), metadata: {} };\n        },\n        isAI: false,\n      };\n\n      registerAdapter('ai-test', aiAdapter);\n      registerAdapter('non-ai-test', nonAIAdapter);\n\n      expect(adapterSupports('ai-test', 'ai')).toBe(true);\n      expect(adapterSupports('non-ai-test', 'ai')).toBe(false);\n      expect(adapterSupports('non-existent', 'ai')).toBe(false);\n    });\n\n    it('should return false for unknown features', () => {\n      registerAdapter('feature-test', {\n        async parse(input) {\n          return { data: input, metadata: {} };\n        },\n        async format(data) {\n          return { data: JSON.stringify(data), metadata: {} };\n        },\n      });\n\n      expect(adapterSupports('feature-test', 'unknown-feature')).toBe(false);\n      expect(adapterSupports('non-existent', 'unknown-feature')).toBe(false);\n    });\n  });\n\n  describe('Pack Management', () => {\n    it('should create pack manifest', () => {\n      const manifest = createPackManifest('test-pack', ['yaml', 'toml'], {\n        version: '2.0.0',\n        description: 'Test pack for YAML and TOML',\n        dependencies: ['yaml-parser', 'toml-parser'],\n      });\n\n      expect(manifest).toEqual({\n        name: 'test-pack',\n        formats: ['yaml', 'toml'],\n        version: '2.0.0',\n        description: 'Test pack for YAML and TOML',\n        dependencies: ['yaml-parser', 'toml-parser'],\n      });\n    });\n\n    it('should create pack manifest with defaults', () => {\n      const manifest = createPackManifest('minimal-pack', ['json']);\n\n      expect(manifest).toEqual({\n        name: 'minimal-pack',\n        formats: ['json'],\n        version: '1.0.0',\n        description: '',\n        dependencies: [],\n      });\n    });\n\n    it('should register pack adapters', () => {\n      const manifest = createPackManifest('test-pack', ['yaml', 'toml']);\n\n      const testAdapters = {\n        yaml: {\n          async parse(input) {\n            return { data: { test: 'yaml' }, metadata: {} };\n          },\n          async format(data) {\n            return { data: 'yaml: test', metadata: {} };\n          },\n          supportsStreaming: true,\n          isAI: false,\n        },\n        toml: {\n          async parse(input) {\n            return { data: { test: 'toml' }, metadata: {} };\n          },\n          async format(data) {\n            return { data: 'test = \"toml\"', metadata: {} };\n          },\n          supportsStreaming: false,\n          isAI: false,\n        },\n        // This adapter should not be registered as it's not in the manifest\n        xml: {\n          async parse(input) {\n            return { data: { test: 'xml' }, metadata: {} };\n          },\n          async format(data) {\n            return { data: '<test>xml</test>', metadata: {} };\n          },\n        },\n      };\n\n      registerPack(manifest, testAdapters);\n\n      expect(getAdapter('yaml')).toBe(testAdapters.yaml);\n      expect(getAdapter('toml')).toBe(testAdapters.toml);\n      expect(getAdapter('xml')).toBeUndefined();\n    });\n\n    it('should handle empty pack registration', () => {\n      const manifest = createPackManifest('empty-pack', []);\n      const adapters = {};\n\n      // Should not throw\n      expect(() => registerPack(manifest, adapters)).not.toThrow();\n    });\n  });\n\n  describe('Provenance Creation', () => {\n    it('should create basic provenance', () => {\n      const provenance = createProvenance('test-adapter');\n\n      expect(provenance).toHaveProperty('timestamp');\n      expect(provenance).toHaveProperty('adapter', 'test-adapter');\n      expect(provenance).toHaveProperty('version');\n      expect(provenance.timestamp).toMatch(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/);\n    });\n\n    it('should create provenance with source and target formats', () => {\n      const provenance = createProvenance('converter', 'json', 'yaml');\n\n      expect(provenance).toHaveProperty('sourceFormat', 'json');\n      expect(provenance).toHaveProperty('targetFormat', 'yaml');\n      expect(provenance).toHaveProperty('adapter', 'converter');\n    });\n\n    it('should create provenance with additional options', () => {\n      const options = {\n        aiModel: 'gpt-4',\n        promptHash: 'abc123',\n        schemaHash: 'def456',\n      };\n\n      const provenance = createProvenance('ai-adapter', 'pdf', 'json', options);\n\n      expect(provenance).toHaveProperty('aiModel', 'gpt-4');\n      expect(provenance).toHaveProperty('promptHash', 'abc123');\n      expect(provenance).toHaveProperty('schemaHash', 'def456');\n    });\n\n    it('should create provenance with partial options', () => {\n      const options = {\n        aiModel: 'gpt-3.5-turbo',\n      };\n\n      const provenance = createProvenance('ai-adapter', undefined, undefined, options);\n\n      expect(provenance).toHaveProperty('aiModel', 'gpt-3.5-turbo');\n      expect(provenance).not.toHaveProperty('promptHash');\n      expect(provenance).not.toHaveProperty('schemaHash');\n    });\n  });\n\n  describe('Utility Functions', () => {\n    it('should generate consistent hash for same input', () => {\n      const input = 'test-string';\n      const hash1 = simpleHash(input);\n      const hash2 = simpleHash(input);\n\n      expect(hash1).toBe(hash2);\n      expect(typeof hash1).toBe('string');\n    });\n\n    it('should generate different hashes for different inputs', () => {\n      const hash1 = simpleHash('string1');\n      const hash2 = simpleHash('string2');\n\n      expect(hash1).not.toBe(hash2);\n    });\n\n    it('should handle empty string hash', () => {\n      const hash = simpleHash('');\n      expect(typeof hash).toBe('string');\n    });\n\n    it('should generate deterministic JSON string', () => {\n      const obj = {\n        c: 3,\n        a: 1,\n        b: 2,\n        nested: {\n          z: 26,\n          x: 24,\n          y: 25,\n        },\n      };\n\n      const result1 = deterministicStringify(obj);\n      const result2 = deterministicStringify(obj);\n\n      expect(result1).toBe(result2);\n      expect(result1).toContain('\"a\": 1');\n      expect(result1).toContain('\"b\": 2');\n      expect(result1).toContain('\"c\": 3');\n    });\n\n    it('should handle arrays in deterministic stringify', () => {\n      const obj = {\n        items: [3, 1, 2],\n        name: 'test',\n      };\n\n      const result = deterministicStringify(obj);\n      expect(result).toContain('\"items\": [3, 1, 2]');\n      expect(result).toContain('\"name\": \"test\"');\n    });\n\n    it('should handle null and undefined values', () => {\n      const obj = {\n        nullValue: undefined,\n        undefinedValue: undefined,\n        normalValue: 'test',\n      };\n\n      const result = deterministicStringify(obj);\n      expect(result).toContain('\"nullValue\": undefined');\n      expect(result).toContain('\"normalValue\": \"test\"');\n      // undefined values should be omitted\n      expect(result).not.toContain('undefinedValue');\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle malformed adapter registration gracefully', () => {\n      // Register adapter with missing methods\n      const malformedAdapter = {\n        async parse(input) {\n          return { data: input, metadata: {} };\n        },\n        // Missing format method\n      };\n\n      expect(() => registerAdapter('malformed', malformedAdapter)).not.toThrow();\n\n      const info = getAdapterInfo('malformed');\n      expect(info.hasParse).toBe(true);\n      expect(info.hasFormat).toBe(false);\n    });\n\n    it('should handle null/undefined adapter registration', () => {\n      expect(() => registerAdapter('null-adapter', undefined)).not.toThrow();\n      expect(() => registerAdapter('undefined-adapter', undefined)).not.toThrow();\n    });\n\n    it('should handle invalid pack manifest creation', () => {\n      expect(() => createPackManifest(undefined, [])).not.toThrow();\n      expect(() => createPackManifest('test', undefined)).not.toThrow();\n    });\n  });\n\n  describe('Performance and Scalability', () => {\n    it('should handle large number of adapter registrations', () => {\n      const startTime = Date.now();\n\n      // Register many adapters\n      for (let i = 0; i < 100; i++) {\n        registerAdapter(`perf-test-${i}`, {\n          async parse(input) {\n            return { data: input, metadata: {} };\n          },\n          async format(data) {\n            return { data: JSON.stringify(data), metadata: {} };\n          },\n        });\n      }\n\n      const endTime = Date.now();\n      const duration = endTime - startTime;\n\n      // Should complete quickly (less than 1 second for 100 adapters)\n      expect(duration).toBeLessThan(1000);\n\n      // Verify all adapters were registered\n      const adapters = listAdapters();\n      expect(adapters.filter(name => name.startsWith('perf-test-'))).toHaveLength(100);\n    });\n\n    it('should handle large adapter info listings efficiently', () => {\n      // Register many adapters\n      for (let i = 0; i < 50; i++) {\n        registerAdapter(`info-perf-${i}`, {\n          async parse(input) {\n            return { data: input, metadata: {} };\n          },\n          async format(data) {\n            return { data: JSON.stringify(data), metadata: {} };\n          },\n        });\n      }\n\n      const startTime = Date.now();\n      const adaptersWithInfo = listAdaptersWithInfo();\n      const endTime = Date.now();\n      const duration = endTime - startTime;\n\n      // Should complete quickly\n      expect(duration).toBeLessThan(500);\n      expect(adaptersWithInfo.length).toBeGreaterThanOrEqual(50);\n    });\n  });\n});\n"
        }
    ]
}