{
  "sourceFile": "src/cli.mjs",
  "activeCommit": 0,
  "commits": [
    {
      "activePatchIndex": 1,
      "patches": [
        {
          "date": 1758643834027,
          "content": "Index: \n===================================================================\n--- \n+++ \n"
        },
        {
          "date": 1758644288211,
          "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,362 +1,1 @@\n-#!/usr/bin/env node\n-\n-/**\n- * ZTF CLI - Command-line interface for zod-to-from\n- * Provides parse, format, and convert commands for schema-validated I/O operations\n- */\n-\n-import { readFile, writeFile } from 'node:fs/promises';\n-import { extname, resolve } from 'node:path';\n-import { convert, formatTo, listAdapters, parseFrom } from './core/index.mjs';\n-\n-// Import adapters to register them\n-import './adapters/data.mjs';\n-\n-/**\n- * CLI configuration and options\n- * @typedef {Object} CLIOptions\n- * @property {string} schema - Path to schema file with export\n- * @property {string} from - Source format\n- * @property {string} to - Target format\n- * @property {string} in - Input file path\n- * @property {string} out - Output file path\n- * @property {boolean} [provenance] - Include provenance metadata\n- * @property {boolean} [deterministic] - Use deterministic output\n- * @property {boolean} [streaming] - Use streaming for large files\n- */\n-\n-/**\n- * Load schema from file\n- * @param {string} schemaPath - Path to schema file (e.g., './schemas/config.mjs#Config')\n- * @returns {Promise<ZodSchema>} Loaded schema\n- */\n-async function loadSchema(schemaPath) {\n-  const [filePath, exportName] = schemaPath.split('#');\n-  const resolvedPath = resolve(process.cwd(), filePath);\n-\n-  try {\n-    const module = await import(resolvedPath);\n-    const schema = exportName ? module[exportName] : module.default;\n-\n-    if (!schema) {\n-      throw new Error(`Schema export '${exportName || 'default'}' not found in ${filePath}`);\n-    }\n-\n-    return schema;\n-  } catch (error) {\n-    throw new Error(`Failed to load schema from ${schemaPath}: ${error.message}`);\n-  }\n-}\n-\n-/**\n- * Get file format from extension\n- * @param {string} filePath - File path\n- * @returns {string} Format name\n- */\n-function getFormatFromPath(filePath) {\n-  const ext = extname(filePath).toLowerCase();\n-  const formatMap = {\n-    '.json': 'json',\n-    '.yaml': 'yaml',\n-    '.yml': 'yaml',\n-    '.toml': 'toml',\n-    '.ini': 'ini',\n-    '.env': 'env',\n-    '.csv': 'csv',\n-    '.md': 'md',\n-    '.html': 'html',\n-    '.xml': 'xml',\n-  };\n-\n-  return formatMap[ext] || 'json';\n-}\n-\n-/**\n- * Parse command - Parse input file into validated object\n- * @param {CLIOptions} options - CLI options\n- */\n-async function parseCommand(options) {\n-  const {\n-    schema: schemaPath,\n-    from,\n-    in: inputPath,\n-    out: outputPath,\n-    provenance,\n-    streaming,\n-  } = options;\n-\n-  try {\n-    // Load schema\n-    const schema = await loadSchema(schemaPath);\n-\n-    // Read input file\n-    const input = await readFile(inputPath, 'utf8');\n-\n-    // Determine format\n-    const format = from || getFormatFromPath(inputPath);\n-\n-    // Parse with options\n-    const parseOptions = { includeProvenance: provenance, streaming };\n-    const result = await parseFrom(schema, format, input, parseOptions);\n-\n-    // Write output\n-    const output = provenance\n-      ? JSON.stringify(result, undefined, 2)\n-      : JSON.stringify(result.data || result, undefined, 2);\n-    await writeFile(outputPath, output, 'utf8');\n-\n-    console.log(`‚úÖ Successfully parsed ${inputPath} to ${outputPath}`);\n-    if (provenance) {\n-      console.log(`üìã Provenance: ${result.provenance.timestamp}`);\n-    }\n-  } catch (error) {\n-    console.error(`‚ùå Parse failed: ${error.message}`);\n-    process.exit(1);\n-  }\n-}\n-\n-/**\n- * Format command - Format validated object to output format\n- * @param {CLIOptions} options - CLI options\n- */\n-async function formatCommand(options) {\n-  const {\n-    schema: schemaPath,\n-    to,\n-    in: inputPath,\n-    out: outputPath,\n-    provenance,\n-    deterministic,\n-  } = options;\n-\n-  try {\n-    // Load schema\n-    const schema = await loadSchema(schemaPath);\n-\n-    // Read input file\n-    const input = await readFile(inputPath, 'utf8');\n-    const data = JSON.parse(input);\n-\n-    // Determine format\n-    const format = to || getFormatFromPath(outputPath);\n-\n-    // Format with options\n-    const formatOptions = { includeProvenance: provenance, deterministic };\n-    const result = await formatTo(schema, format, data, formatOptions);\n-\n-    // Write output\n-    const output = provenance ? JSON.stringify(result, undefined, 2) : result;\n-    await writeFile(outputPath, output, 'utf8');\n-\n-    console.log(`‚úÖ Successfully formatted ${inputPath} to ${outputPath}`);\n-    if (provenance) {\n-      console.log(`üìã Provenance: ${result.provenance.timestamp}`);\n-    }\n-  } catch (error) {\n-    console.error(`‚ùå Format failed: ${error.message}`);\n-    process.exit(1);\n-  }\n-}\n-\n-/**\n- * Convert command - Convert between formats in one step\n- * @param {CLIOptions} options - CLI options\n- */\n-async function convertCommand(options) {\n-  const {\n-    schema: schemaPath,\n-    from,\n-    to,\n-    in: inputPath,\n-    out: outputPath,\n-    provenance,\n-    deterministic,\n-    streaming,\n-  } = options;\n-\n-  try {\n-    // Load schema\n-    const schema = await loadSchema(schemaPath);\n-\n-    // Read input file\n-    const input = await readFile(inputPath, 'utf8');\n-\n-    // Determine formats\n-    const sourceFormat = from || getFormatFromPath(inputPath);\n-    const targetFormat = to || getFormatFromPath(outputPath);\n-\n-    // Convert with options\n-    const convertOptions = { includeProvenance: provenance, deterministic, streaming };\n-    const result = await convert(\n-      schema,\n-      { from: sourceFormat, to: targetFormat },\n-      input,\n-      convertOptions\n-    );\n-\n-    // Write output\n-    const output = provenance ? JSON.stringify(result, undefined, 2) : result;\n-    await writeFile(outputPath, output, 'utf8');\n-\n-    console.log(\n-      `‚úÖ Successfully converted ${inputPath} (${sourceFormat}) to ${outputPath} (${targetFormat})`\n-    );\n-    if (provenance) {\n-      console.log(`üìã Provenance: ${result.provenance.timestamp}`);\n-    }\n-  } catch (error) {\n-    console.error(`‚ùå Convert failed: ${error.message}`);\n-    process.exit(1);\n-  }\n-}\n-\n-/**\n- * List command - List available adapters\n- */\n-async function listCommand() {\n-  try {\n-    const adapters = listAdapters();\n-    console.log('üì¶ Available adapters:');\n-    for (const adapter of adapters) {\n-      console.log(`  ‚Ä¢ ${adapter}`);\n-    }\n-  } catch (error) {\n-    console.error(`‚ùå List failed: ${error.message}`);\n-    process.exit(1);\n-  }\n-}\n-\n-/**\n- * Show help information\n- */\n-function showHelp() {\n-  console.log(`\n-üîß ZTF CLI - Schema-validated I/O operations\n-\n-USAGE:\n-  ztf <command> [options]\n-\n-COMMANDS:\n-  parse     Parse input file into validated object\n-  format    Format validated object to output format  \n-  convert   Convert between formats in one step\n-  list      List available adapters\n-  help      Show this help\n-\n-OPTIONS:\n-  --schema <path>        Path to schema file with export (e.g., ./schemas/config.mjs#Config)\n-  --from <format>        Source format (auto-detected from file extension if not specified)\n-  --to <format>          Target format (auto-detected from file extension if not specified)\n-  --in <path>            Input file path\n-  --out <path>           Output file path\n-  --provenance           Include provenance metadata in output\n-  --deterministic        Use deterministic output (stable key ordering)\n-  --streaming            Use streaming for large files\n-  --help                 Show help\n-\n-EXAMPLES:\n-  # Parse YAML file into JSON object\n-  ztf parse --schema ./schemas/config.mjs#Config --from yaml --in config.yaml --out config.json\n-\n-  # Format JSON object into TOML file\n-  ztf format --schema ./schemas/config.mjs#Config --to toml --in config.json --out config.toml\n-\n-  # Convert CSV file directly to XLSX spreadsheet\n-  ztf convert --schema ./schemas/report.mjs#Report[] --from csv --to xlsx --in data.csv --out out.xlsx\n-\n-  # List available adapters\n-  ztf list\n-`);\n-}\n-\n-/**\n- * Parse command line arguments\n- * @param {string[]} args - Command line arguments\n- * @returns {Object} Parsed command and options\n- */\n-function parseArgs(args) {\n-  const command = args[0];\n-  const options = {};\n-\n-  for (let i = 1; i < args.length; i += 2) {\n-    const key = args[i]?.replace('--', '');\n-    const value = args[i + 1];\n-\n-    if (key && value) {\n-      // Convert boolean flags\n-      if (['provenance', 'deterministic', 'streaming'].includes(key)) {\n-        options[key] = true;\n-        i--; // Don't skip the next argument\n-      } else {\n-        options[key] = value;\n-      }\n-    }\n-  }\n-\n-  return { command, options };\n-}\n-\n-/**\n- * Main CLI entry point\n- */\n-async function main() {\n-  const args = process.argv.slice(2);\n-\n-  if (args.length === 0 || args[0] === 'help' || args.includes('--help')) {\n-    showHelp();\n-    return;\n-  }\n-\n-  const { command, options } = parseArgs(args);\n-\n-  // Validate required options based on command\n-  if (['parse', 'format', 'convert'].includes(command)) {\n-    if (!options.schema) {\n-      console.error('‚ùå --schema is required for parse, format, and convert commands');\n-      process.exit(1);\n-    }\n-    if (!options.in) {\n-      console.error('‚ùå --in is required for parse, format, and convert commands');\n-      process.exit(1);\n-    }\n-    if (!options.out) {\n-      console.error('‚ùå --out is required for parse, format, and convert commands');\n-      process.exit(1);\n-    }\n-  }\n-\n-  // Execute command\n-  switch (command) {\n-    case 'parse': {\n-      await parseCommand(options);\n-      break;\n-    }\n-    case 'format': {\n-      await formatCommand(options);\n-      break;\n-    }\n-    case 'convert': {\n-      await convertCommand(options);\n-      break;\n-    }\n-    case 'list': {\n-      await listCommand();\n-      break;\n-    }\n-    default: {\n-      console.error(`‚ùå Unknown command: ${command}`);\n-      console.error('Run \"ztf help\" for usage information');\n-      process.exit(1);\n-    }\n-  }\n-}\n-\n-// Run CLI if this file is executed directly\n-if (import.meta.url === `file://${process.argv[1]}`) {\n-  try {\n-    await main();\n-  } catch (error) {\n-    console.error(`‚ùå CLI error: ${error.message}`);\n-    process.exit(1);\n-  }\n-}\n+ \n\\ No newline at end of file\n"
        }
      ],
      "date": 1758643834027,
      "name": "Commit-0",
      "content": "#!/usr/bin/env node\n\n/**\n * ZTF CLI - Command-line interface for zod-to-from\n * Provides parse, format, and convert commands for schema-validated I/O operations\n */\n\nimport { readFile, writeFile } from 'node:fs/promises';\nimport { extname, resolve } from 'node:path';\nimport { convert, formatTo, listAdapters, parseFrom } from './core/index.mjs';\n\n// Import adapters to register them\nimport './adapters/data.mjs';\n\n/**\n * CLI configuration and options\n * @typedef {Object} CLIOptions\n * @property {string} schema - Path to schema file with export\n * @property {string} from - Source format\n * @property {string} to - Target format\n * @property {string} in - Input file path\n * @property {string} out - Output file path\n * @property {boolean} [provenance] - Include provenance metadata\n * @property {boolean} [deterministic] - Use deterministic output\n * @property {boolean} [streaming] - Use streaming for large files\n */\n\n/**\n * Load schema from file\n * @param {string} schemaPath - Path to schema file (e.g., './schemas/config.mjs#Config')\n * @returns {Promise<ZodSchema>} Loaded schema\n */\nasync function loadSchema(schemaPath) {\n  const [filePath, exportName] = schemaPath.split('#');\n  const resolvedPath = resolve(process.cwd(), filePath);\n\n  try {\n    const module = await import(resolvedPath);\n    const schema = exportName ? module[exportName] : module.default;\n\n    if (!schema) {\n      throw new Error(`Schema export '${exportName || 'default'}' not found in ${filePath}`);\n    }\n\n    return schema;\n  } catch (error) {\n    throw new Error(`Failed to load schema from ${schemaPath}: ${error.message}`);\n  }\n}\n\n/**\n * Get file format from extension\n * @param {string} filePath - File path\n * @returns {string} Format name\n */\nfunction getFormatFromPath(filePath) {\n  const ext = extname(filePath).toLowerCase();\n  const formatMap = {\n    '.json': 'json',\n    '.yaml': 'yaml',\n    '.yml': 'yaml',\n    '.toml': 'toml',\n    '.ini': 'ini',\n    '.env': 'env',\n    '.csv': 'csv',\n    '.md': 'md',\n    '.html': 'html',\n    '.xml': 'xml',\n  };\n\n  return formatMap[ext] || 'json';\n}\n\n/**\n * Parse command - Parse input file into validated object\n * @param {CLIOptions} options - CLI options\n */\nasync function parseCommand(options) {\n  const {\n    schema: schemaPath,\n    from,\n    in: inputPath,\n    out: outputPath,\n    provenance,\n    streaming,\n  } = options;\n\n  try {\n    // Load schema\n    const schema = await loadSchema(schemaPath);\n\n    // Read input file\n    const input = await readFile(inputPath, 'utf8');\n\n    // Determine format\n    const format = from || getFormatFromPath(inputPath);\n\n    // Parse with options\n    const parseOptions = { includeProvenance: provenance, streaming };\n    const result = await parseFrom(schema, format, input, parseOptions);\n\n    // Write output\n    const output = provenance\n      ? JSON.stringify(result, undefined, 2)\n      : JSON.stringify(result.data || result, undefined, 2);\n    await writeFile(outputPath, output, 'utf8');\n\n    console.log(`‚úÖ Successfully parsed ${inputPath} to ${outputPath}`);\n    if (provenance) {\n      console.log(`üìã Provenance: ${result.provenance.timestamp}`);\n    }\n  } catch (error) {\n    console.error(`‚ùå Parse failed: ${error.message}`);\n    process.exit(1);\n  }\n}\n\n/**\n * Format command - Format validated object to output format\n * @param {CLIOptions} options - CLI options\n */\nasync function formatCommand(options) {\n  const {\n    schema: schemaPath,\n    to,\n    in: inputPath,\n    out: outputPath,\n    provenance,\n    deterministic,\n  } = options;\n\n  try {\n    // Load schema\n    const schema = await loadSchema(schemaPath);\n\n    // Read input file\n    const input = await readFile(inputPath, 'utf8');\n    const data = JSON.parse(input);\n\n    // Determine format\n    const format = to || getFormatFromPath(outputPath);\n\n    // Format with options\n    const formatOptions = { includeProvenance: provenance, deterministic };\n    const result = await formatTo(schema, format, data, formatOptions);\n\n    // Write output\n    const output = provenance ? JSON.stringify(result, undefined, 2) : result;\n    await writeFile(outputPath, output, 'utf8');\n\n    console.log(`‚úÖ Successfully formatted ${inputPath} to ${outputPath}`);\n    if (provenance) {\n      console.log(`üìã Provenance: ${result.provenance.timestamp}`);\n    }\n  } catch (error) {\n    console.error(`‚ùå Format failed: ${error.message}`);\n    process.exit(1);\n  }\n}\n\n/**\n * Convert command - Convert between formats in one step\n * @param {CLIOptions} options - CLI options\n */\nasync function convertCommand(options) {\n  const {\n    schema: schemaPath,\n    from,\n    to,\n    in: inputPath,\n    out: outputPath,\n    provenance,\n    deterministic,\n    streaming,\n  } = options;\n\n  try {\n    // Load schema\n    const schema = await loadSchema(schemaPath);\n\n    // Read input file\n    const input = await readFile(inputPath, 'utf8');\n\n    // Determine formats\n    const sourceFormat = from || getFormatFromPath(inputPath);\n    const targetFormat = to || getFormatFromPath(outputPath);\n\n    // Convert with options\n    const convertOptions = { includeProvenance: provenance, deterministic, streaming };\n    const result = await convert(\n      schema,\n      { from: sourceFormat, to: targetFormat },\n      input,\n      convertOptions\n    );\n\n    // Write output\n    const output = provenance ? JSON.stringify(result, undefined, 2) : result;\n    await writeFile(outputPath, output, 'utf8');\n\n    console.log(\n      `‚úÖ Successfully converted ${inputPath} (${sourceFormat}) to ${outputPath} (${targetFormat})`\n    );\n    if (provenance) {\n      console.log(`üìã Provenance: ${result.provenance.timestamp}`);\n    }\n  } catch (error) {\n    console.error(`‚ùå Convert failed: ${error.message}`);\n    process.exit(1);\n  }\n}\n\n/**\n * List command - List available adapters\n */\nasync function listCommand() {\n  try {\n    const adapters = listAdapters();\n    console.log('üì¶ Available adapters:');\n    for (const adapter of adapters) {\n      console.log(`  ‚Ä¢ ${adapter}`);\n    }\n  } catch (error) {\n    console.error(`‚ùå List failed: ${error.message}`);\n    process.exit(1);\n  }\n}\n\n/**\n * Show help information\n */\nfunction showHelp() {\n  console.log(`\nüîß ZTF CLI - Schema-validated I/O operations\n\nUSAGE:\n  ztf <command> [options]\n\nCOMMANDS:\n  parse     Parse input file into validated object\n  format    Format validated object to output format  \n  convert   Convert between formats in one step\n  list      List available adapters\n  help      Show this help\n\nOPTIONS:\n  --schema <path>        Path to schema file with export (e.g., ./schemas/config.mjs#Config)\n  --from <format>        Source format (auto-detected from file extension if not specified)\n  --to <format>          Target format (auto-detected from file extension if not specified)\n  --in <path>            Input file path\n  --out <path>           Output file path\n  --provenance           Include provenance metadata in output\n  --deterministic        Use deterministic output (stable key ordering)\n  --streaming            Use streaming for large files\n  --help                 Show help\n\nEXAMPLES:\n  # Parse YAML file into JSON object\n  ztf parse --schema ./schemas/config.mjs#Config --from yaml --in config.yaml --out config.json\n\n  # Format JSON object into TOML file\n  ztf format --schema ./schemas/config.mjs#Config --to toml --in config.json --out config.toml\n\n  # Convert CSV file directly to XLSX spreadsheet\n  ztf convert --schema ./schemas/report.mjs#Report[] --from csv --to xlsx --in data.csv --out out.xlsx\n\n  # List available adapters\n  ztf list\n`);\n}\n\n/**\n * Parse command line arguments\n * @param {string[]} args - Command line arguments\n * @returns {Object} Parsed command and options\n */\nfunction parseArgs(args) {\n  const command = args[0];\n  const options = {};\n\n  for (let i = 1; i < args.length; i += 2) {\n    const key = args[i]?.replace('--', '');\n    const value = args[i + 1];\n\n    if (key && value) {\n      // Convert boolean flags\n      if (['provenance', 'deterministic', 'streaming'].includes(key)) {\n        options[key] = true;\n        i--; // Don't skip the next argument\n      } else {\n        options[key] = value;\n      }\n    }\n  }\n\n  return { command, options };\n}\n\n/**\n * Main CLI entry point\n */\nasync function main() {\n  const args = process.argv.slice(2);\n\n  if (args.length === 0 || args[0] === 'help' || args.includes('--help')) {\n    showHelp();\n    return;\n  }\n\n  const { command, options } = parseArgs(args);\n\n  // Validate required options based on command\n  if (['parse', 'format', 'convert'].includes(command)) {\n    if (!options.schema) {\n      console.error('‚ùå --schema is required for parse, format, and convert commands');\n      process.exit(1);\n    }\n    if (!options.in) {\n      console.error('‚ùå --in is required for parse, format, and convert commands');\n      process.exit(1);\n    }\n    if (!options.out) {\n      console.error('‚ùå --out is required for parse, format, and convert commands');\n      process.exit(1);\n    }\n  }\n\n  // Execute command\n  switch (command) {\n    case 'parse': {\n      await parseCommand(options);\n      break;\n    }\n    case 'format': {\n      await formatCommand(options);\n      break;\n    }\n    case 'convert': {\n      await convertCommand(options);\n      break;\n    }\n    case 'list': {\n      await listCommand();\n      break;\n    }\n    default: {\n      console.error(`‚ùå Unknown command: ${command}`);\n      console.error('Run \"ztf help\" for usage information');\n      process.exit(1);\n    }\n  }\n}\n\n// Run CLI if this file is executed directly\nif (import.meta.url === `file://${process.argv[1]}`) {\n  try {\n    await main();\n  } catch (error) {\n    console.error(`‚ùå CLI error: ${error.message}`);\n    process.exit(1);\n  }\n}\n"
    }
  ]
}
