{
    "sourceFile": "src/cli/commands/artifact.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758644495329,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758644495329,
            "name": "Commit-0",
            "content": "/**\n * Artifact command implementations\n * @fileoverview Commands for operating on data artifacts\n */\n\nimport { readFile, writeFile } from 'node:fs/promises';\nimport { extname, resolve } from 'node:path';\nimport { convert as coreConvert, formatTo, parseFrom } from '../../core/index.mjs';\n\n/**\n * Load a schema from a file path\n * @param {string} schemaPath - Path to schema file\n * @returns {Promise<Object>} The loaded schema\n */\nasync function loadSchema(schemaPath) {\n  if (!schemaPath) {\n    throw new Error('Schema path is required');\n  }\n\n  const [filePath, exportName] = schemaPath.split('#');\n  const resolvedPath = resolve(process.cwd(), filePath);\n\n  try {\n    const module = await import(resolvedPath);\n    const schema = exportName ? module[exportName] : module.default;\n\n    if (!schema) {\n      throw new Error(`Schema export '${exportName || 'default'}' not found in ${filePath}`);\n    }\n\n    return schema;\n  } catch (error) {\n    throw new Error(`Failed to load schema from ${schemaPath}: ${error.message}`);\n  }\n}\n\n/**\n * Get format from file extension\n * @param {string} filePath - File path\n * @returns {string} Format name\n */\nfunction getFormatFromPath(filePath) {\n  const ext = extname(filePath).toLowerCase();\n  const formatMap = {\n    '.json': 'json',\n    '.yaml': 'yaml',\n    '.yml': 'yaml',\n    '.toml': 'toml',\n    '.csv': 'csv',\n    '.tsv': 'csv',\n    '.ndjson': 'ndjson',\n    '.jsonl': 'ndjson',\n    '.ttl': 'ttl',\n    '.turtle': 'ttl',\n    '.xml': 'xml',\n  };\n\n  return formatMap[ext] || 'json';\n}\n\n/**\n * Convert command - Convert between formats\n * @param {Object} options - Command options\n */\nexport async function convert(options) {\n  const {\n    schema: schemaPath,\n    from,\n    to,\n    in: inputPath,\n    out: outputPath,\n    repair,\n    llmPrompt,\n    provenance,\n    deterministic,\n    streaming,\n  } = options;\n\n  try {\n    // Load schema\n    const schema = await loadSchema(schemaPath);\n\n    // Read input file\n    const input = await readFile(inputPath, 'utf8');\n\n    // Determine formats\n    const sourceFormat = from || getFormatFromPath(inputPath);\n    const targetFormat = to || getFormatFromPath(outputPath);\n\n    // Convert with options\n    const convertOptions = {\n      includeProvenance: provenance,\n      deterministic,\n      streaming,\n      adapter: {\n        repair,\n        llmPrompt,\n      },\n    };\n    const result = await coreConvert(\n      schema,\n      { from: sourceFormat, to: targetFormat },\n      input,\n      convertOptions\n    );\n\n    // Write output\n    const output = provenance ? JSON.stringify(result, undefined, 2) : result;\n    await writeFile(outputPath, output, 'utf8');\n\n    console.log(\n      `‚úÖ Successfully converted ${inputPath} (${sourceFormat}) to ${outputPath} (${targetFormat})`\n    );\n    if (provenance) {\n      console.log(`üìã Provenance: ${result.provenance.timestamp}`);\n    }\n  } catch (error) {\n    console.error(`‚ùå Convert failed: ${error.message}`);\n    throw error;\n  }\n}\n\n/**\n * Parse command - Parse and validate input\n * @param {Object} options - Command options\n */\nexport async function parse(options) {\n  const {\n    schema: schemaPath,\n    from,\n    in: inputPath,\n    out: outputPath,\n    repair,\n    llmPrompt,\n    provenance,\n    streaming,\n  } = options;\n\n  try {\n    // Load schema\n    const schema = await loadSchema(schemaPath);\n\n    // Read input file\n    const input = await readFile(inputPath, 'utf8');\n\n    // Determine format\n    const format = from || getFormatFromPath(inputPath);\n\n    // Parse with options\n    const parseOptions = {\n      includeProvenance: provenance,\n      streaming,\n      adapter: {\n        repair,\n        llmPrompt,\n      },\n    };\n    const result = await parseFrom(schema, format, input, parseOptions);\n\n    // Write output\n    const output = provenance\n      ? JSON.stringify(result, undefined, 2)\n      : JSON.stringify(result.data || result, undefined, 2);\n    await writeFile(outputPath, output, 'utf8');\n\n    console.log(`‚úÖ Successfully parsed ${inputPath} to ${outputPath}`);\n    if (provenance) {\n      console.log(`üìã Provenance: ${result.provenance.timestamp}`);\n    }\n  } catch (error) {\n    console.error(`‚ùå Parse failed: ${error.message}`);\n    throw error;\n  }\n}\n\n/**\n * Format command - Format validated data\n * @param {Object} options - Command options\n */\nexport async function format(options) {\n  const {\n    schema: schemaPath,\n    to,\n    in: inputPath,\n    out: outputPath,\n    repair,\n    llmPrompt,\n    provenance,\n    deterministic,\n  } = options;\n\n  try {\n    // Load schema\n    const schema = await loadSchema(schemaPath);\n\n    // Read input file\n    const input = await readFile(inputPath, 'utf8');\n    const data = JSON.parse(input);\n\n    // Determine format\n    const format = to || getFormatFromPath(outputPath);\n\n    // Format with options\n    const formatOptions = {\n      includeProvenance: provenance,\n      deterministic,\n      adapter: {\n        repair,\n        llmPrompt,\n      },\n    };\n    const result = await formatTo(schema, format, data, formatOptions);\n\n    // Write output\n    const output = provenance ? JSON.stringify(result, undefined, 2) : result;\n    await writeFile(outputPath, output, 'utf8');\n\n    console.log(`‚úÖ Successfully formatted ${inputPath} to ${outputPath}`);\n    if (provenance) {\n      console.log(`üìã Provenance: ${result.provenance.timestamp}`);\n    }\n  } catch (error) {\n    console.error(`‚ùå Format failed: ${error.message}`);\n    throw error;\n  }\n}\n"
        }
    ]
}