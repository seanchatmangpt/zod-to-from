{
    "sourceFile": "src/cli/commands/test.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758644495344,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758644495344,
            "name": "Commit-0",
            "content": "/**\n * Test command implementations\n * @fileoverview Commands for running validation and integrity tests\n */\n\nimport { readFile, writeFile } from 'node:fs/promises';\nimport { resolve } from 'node:path';\nimport { formatTo, parseFrom } from '../../core/index.mjs';\n\n/**\n * Load a schema from a file path\n * @param {string} schemaPath - Path to schema file\n * @returns {Promise<Object>} The loaded schema\n */\nasync function loadSchema(schemaPath) {\n  if (!schemaPath) {\n    throw new Error('Schema path is required');\n  }\n\n  const [filePath, exportName] = schemaPath.split('#');\n  const resolvedPath = resolve(process.cwd(), filePath);\n\n  try {\n    const module = await import(resolvedPath);\n    const schema = exportName ? module[exportName] : module.default;\n\n    if (!schema) {\n      throw new Error(`Schema export '${exportName || 'default'}' not found in ${filePath}`);\n    }\n\n    return schema;\n  } catch (error) {\n    throw new Error(`Failed to load schema from ${schemaPath}: ${error.message}`);\n  }\n}\n\n/**\n * Run command - Execute a named test contract\n * @param {Object} options - Command options\n */\nexport async function run(options) {\n  const {\n    type: testType,\n    schema: schemaPath,\n    format: testFormat,\n    in: inputPath,\n    out: outputPath,\n  } = options;\n\n  try {\n    // Load schema\n    const schema = await loadSchema(schemaPath);\n\n    // Read input data\n    const input = await readFile(inputPath, 'utf8');\n\n    switch (testType) {\n      case 'round-trip': {\n        await runRoundTripTest(schema, testFormat, input, outputPath);\n        break;\n      }\n      case 'fuzz': {\n        await runFuzzTest(schema, testFormat, input, outputPath);\n        break;\n      }\n      case 'validation': {\n        await runValidationTest(schema, testFormat, input, outputPath);\n        break;\n      }\n      default: {\n        throw new Error(`Unknown test type: ${testType}`);\n      }\n    }\n  } catch (error) {\n    console.error(`‚ùå Test failed: ${error.message}`);\n    throw error;\n  }\n}\n\n/**\n * Run a round-trip test to check for data loss\n * @param {Object} schema - Zod schema\n * @param {string} format - Test format\n * @param {string} input - Input data\n * @param {string} outputPath - Output path for results\n */\nasync function runRoundTripTest(schema, format, input, outputPath) {\n  console.log(`üîÑ Running round-trip test for format: ${format}`);\n\n  try {\n    // Parse input\n    const parsed = await parseFrom(schema, format, input);\n\n    // Format back to same format\n    const formatted = await formatTo(schema, format, parsed);\n\n    // Parse again to check for consistency\n    const reparsed = await parseFrom(schema, format, formatted);\n\n    // Compare results\n    const originalJson = JSON.stringify(parsed);\n    const roundTripJson = JSON.stringify(reparsed);\n\n    if (originalJson === roundTripJson) {\n      console.log('‚úÖ Round-trip test passed: No data loss detected');\n    } else {\n      console.log('‚ö†Ô∏è  Round-trip test warning: Minor data differences detected');\n      console.log('   This may be expected for some formats (e.g., comment preservation)');\n    }\n\n    // Write test results\n    const results = {\n      testType: 'round-trip',\n      format,\n      passed: originalJson === roundTripJson,\n      originalSize: originalJson.length,\n      roundTripSize: roundTripJson.length,\n      timestamp: new Date().toISOString(),\n    };\n\n    await writeFile(outputPath, JSON.stringify(results, undefined, 2), 'utf8');\n    console.log(`üìã Test results written to: ${outputPath}`);\n  } catch (error) {\n    console.error(`‚ùå Round-trip test failed: ${error.message}`);\n    throw error;\n  }\n}\n\n/**\n * Run a fuzz test with random data\n * @param {Object} schema - Zod schema\n * @param {string} format - Test format\n * @param {string} input - Input data\n * @param {string} outputPath - Output path for results\n */\nasync function runFuzzTest(schema, format, input, outputPath) {\n  console.log(`üé≤ Running fuzz test for format: ${format}`);\n\n  try {\n    // Parse input to get valid data structure\n    const validData = await parseFrom(schema, format, input);\n\n    // Generate variations (placeholder for actual fuzzing)\n    const variations = [\n      validData,\n      // Add more variations here\n    ];\n\n    let passed = 0;\n    let failed = 0;\n\n    for (const variation of variations) {\n      try {\n        // Try to format and parse back\n        const formatted = await formatTo(schema, format, variation);\n        const reparsed = await parseFrom(schema, format, formatted);\n\n        // Validate the result\n        schema.parse(reparsed);\n        passed++;\n      } catch (error) {\n        failed++;\n        console.log(`‚ö†Ô∏è  Fuzz test variation failed: ${error.message}`);\n      }\n    }\n\n    console.log(`‚úÖ Fuzz test completed: ${passed} passed, ${failed} failed`);\n\n    // Write test results\n    const results = {\n      testType: 'fuzz',\n      format,\n      passed,\n      failed,\n      total: variations.length,\n      timestamp: new Date().toISOString(),\n    };\n\n    await writeFile(outputPath, JSON.stringify(results, undefined, 2), 'utf8');\n    console.log(`üìã Test results written to: ${outputPath}`);\n  } catch (error) {\n    console.error(`‚ùå Fuzz test failed: ${error.message}`);\n    throw error;\n  }\n}\n\n/**\n * Run a validation test\n * @param {Object} schema - Zod schema\n * @param {string} format - Test format\n * @param {string} input - Input data\n * @param {string} outputPath - Output path for results\n */\nasync function runValidationTest(schema, format, input, outputPath) {\n  console.log(`‚úÖ Running validation test for format: ${format}`);\n\n  try {\n    // Parse and validate\n    const parsed = await parseFrom(schema, format, input);\n\n    // Additional validation checks\n    const isValid = schema.safeParse(parsed).success;\n\n    if (isValid) {\n      console.log('‚úÖ Validation test passed: Data is valid against schema');\n    } else {\n      console.log('‚ùå Validation test failed: Data is invalid against schema');\n    }\n\n    // Write test results\n    const results = {\n      testType: 'validation',\n      format,\n      passed: isValid,\n      timestamp: new Date().toISOString(),\n    };\n\n    await writeFile(outputPath, JSON.stringify(results, undefined, 2), 'utf8');\n    console.log(`üìã Test results written to: ${outputPath}`);\n  } catch (error) {\n    console.error(`‚ùå Validation test failed: ${error.message}`);\n    throw error;\n  }\n}\n"
        }
    ]
}