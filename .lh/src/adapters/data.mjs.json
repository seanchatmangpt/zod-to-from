{
  "sourceFile": "src/adapters/data.mjs",
  "activeCommit": 0,
  "commits": [
    {
      "activePatchIndex": 0,
      "patches": [
        {
          "date": 1758643834027,
          "content": "Index: \n===================================================================\n--- \n+++ \n"
        }
      ],
      "date": 1758643834027,
      "name": "Commit-0",
      "content": "/**\n * @typedef {import('../core/index.mjs').Adapter} Adapter\n */\n\nimport { parse as csvParse } from 'csv-parse/sync';\nimport { stringify as csvStringifyAsync } from 'csv-stringify';\nimport { promisify } from 'node:util';\nimport { createPackManifest, registerPack } from '../core/index.mjs';\n\n/**\n * CSV adapter for parsing and formatting CSV data\n */\nconst csvAdapter = {\n  async parse(input, opts = {}) {\n    const options = {\n      columns: true,\n      skip_empty_lines: true,\n      ...opts,\n    };\n\n    const records = csvParse(input, options);\n\n    return {\n      data: records,\n      metadata: {\n        format: 'csv',\n        recordCount: records.length,\n        columnCount: records.length > 0 ? Object.keys(records[0]).length : 0,\n        ...opts,\n      },\n    };\n  },\n\n  async format(data, opts = {}) {\n    const options = {\n      header: true,\n      ...opts,\n    };\n\n    const stringifyAsync = promisify(csvStringifyAsync);\n    const csv = await stringifyAsync(data, options);\n\n    return {\n      data: csv,\n      metadata: {\n        format: 'csv',\n        outputSize: csv.length,\n        recordCount: Array.isArray(data) ? data.length : 1,\n        ...opts,\n      },\n    };\n  },\n\n  supportsStreaming: true,\n  isAI: false,\n  version: '1.0.0',\n};\n\n/**\n * NDJSON (Newline Delimited JSON) adapter\n */\nconst ndjsonAdapter = {\n  async parse(input, opts = {}) {\n    const lines = input.trim().split('\\n');\n    const records = lines.map(line => {\n      try {\n        return JSON.parse(line);\n      } catch {\n        throw new Error(`Invalid JSON line: ${line}`);\n      }\n    });\n\n    return {\n      data: records,\n      metadata: {\n        format: 'ndjson',\n        recordCount: records.length,\n        ...opts,\n      },\n    };\n  },\n\n  async format(data, opts = {}) {\n    const records = Array.isArray(data) ? data : [data];\n    const ndjson = records.map(record => JSON.stringify(record)).join('\\n');\n\n    return {\n      data: ndjson,\n      metadata: {\n        format: 'ndjson',\n        outputSize: ndjson.length,\n        recordCount: records.length,\n        ...opts,\n      },\n    };\n  },\n\n  supportsStreaming: true,\n  isAI: false,\n  version: '1.0.0',\n};\n\n/**\n * SQLite adapter for database operations\n */\nconst sqliteAdapter = {\n  async parse(input, opts = {}) {\n    const sqlite3 = await import('sqlite3');\n    const { Database } = sqlite3.default;\n\n    return new Promise((resolve, reject) => {\n      const db = new Database(input);\n      const query = opts.query || 'SELECT * FROM sqlite_master';\n\n      db.all(query, [], (err, rows) => {\n        if (err) {\n          reject(new Error(`SQLite query failed: ${err.message}`));\n          return;\n        }\n\n        db.close(closeErr => {\n          if (closeErr) {\n            console.warn('Warning: Failed to close database:', closeErr.message);\n          }\n\n          resolve({\n            data: rows,\n            metadata: {\n              format: 'sqlite',\n              recordCount: rows.length,\n              query,\n              ...opts,\n            },\n          });\n        });\n      });\n    });\n  },\n\n  async format(data, opts = {}) {\n    // Note: SQLite formatting would require creating a database file\n    // This is a complex operation that would need schema definition\n    throw new Error('SQLite formatting not yet implemented - requires schema definition');\n  },\n\n  supportsStreaming: false,\n  isAI: false,\n  version: '1.0.0',\n};\n\n/**\n * Parquet adapter placeholder\n * Note: Would require parquet-wasm or similar library\n */\nconst parquetAdapter = {\n  async parse(input, opts = {}) {\n    throw new Error('Parquet support requires additional dependencies (parquet-wasm)');\n  },\n\n  async format(data, opts = {}) {\n    throw new Error('Parquet support requires additional dependencies (parquet-wasm)');\n  },\n\n  supportsStreaming: false,\n  isAI: false,\n  version: '1.0.0',\n};\n\n/**\n * Arrow adapter placeholder\n * Note: Would require apache-arrow library\n */\nconst arrowAdapter = {\n  async parse(input, opts = {}) {\n    throw new Error('Arrow support requires additional dependencies (apache-arrow)');\n  },\n\n  async format(data, opts = {}) {\n    throw new Error('Arrow support requires additional dependencies (apache-arrow)');\n  },\n\n  supportsStreaming: true,\n  isAI: false,\n  version: '1.0.0',\n};\n\n/**\n * Avro adapter placeholder\n * Note: Would require avro-js library\n */\nconst avroAdapter = {\n  async parse(input, opts = {}) {\n    throw new Error('Avro support requires additional dependencies (avro-js)');\n  },\n\n  async format(data, opts = {}) {\n    throw new Error('Avro support requires additional dependencies (avro-js)');\n  },\n\n  supportsStreaming: false,\n  isAI: false,\n  version: '1.0.0',\n};\n\n/**\n * Protobuf adapter placeholder\n * Note: Would require protobufjs library\n */\nconst protobufAdapter = {\n  async parse(input, opts = {}) {\n    throw new Error('Protobuf support requires additional dependencies (protobufjs)');\n  },\n\n  async format(data, opts = {}) {\n    throw new Error('Protobuf support requires additional dependencies (protobufjs)');\n  },\n\n  supportsStreaming: false,\n  isAI: false,\n  version: '1.0.0',\n};\n\n// Create pack manifest\nconst packManifest = createPackManifest(\n  'ztf-pack-data',\n  ['csv', 'ndjson', 'sqlite', 'parquet', 'arrow', 'avro', 'protobuf'],\n  {\n    version: '1.0.0',\n    description: 'Data analytics format adapters for ZTF',\n    dependencies: ['csv-parse', 'csv-stringify', 'sqlite3'],\n  }\n);\n\n// Register all adapters\nconst adapters = {\n  csv: csvAdapter,\n  ndjson: ndjsonAdapter,\n  sqlite: sqliteAdapter,\n  parquet: parquetAdapter,\n  arrow: arrowAdapter,\n  avro: avroAdapter,\n  protobuf: protobufAdapter,\n};\n\nregisterPack(packManifest, adapters);\n\nexport {\n  arrowAdapter,\n  avroAdapter,\n  csvAdapter,\n  ndjsonAdapter,\n  parquetAdapter,\n  protobufAdapter,\n  sqliteAdapter,\n};\n"
    }
  ]
}
