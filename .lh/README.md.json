{
    "sourceFile": "README.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1758642289491,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758647039095,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,171 +1,333 @@\n-# zod-to-from\n+# zod-to-from (ZTF)\n \n-<!-- automd:badges color=yellow -->\n+[![npm version](https://img.shields.io/npm/v/zod-to-from.svg)](https://www.npmjs.com/package/zod-to-from)\n+[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n+[![Build Status](https://img.shields.io/badge/build-passing-brightgreen.svg)](https://github.com/unjs/zod-to-from)\n \n-[![npm version](https://img.shields.io/npm/v/zod-to-from?color=yellow)](https://npmjs.com/package/zod-to-from)\n-[![npm downloads](https://img.shields.io/npm/dm/zod-to-from?color=yellow)](https://npm.chart.dev/zod-to-from)\n+ZTF is a universal I/O conversion layer centered on Zod schemas. The core\n+philosophy is that Zod is the single source of truth, and all other formats are\n+merely views of that truth. It aims to make Zod the universal intermediate\n+representation for all application I/O.\n \n-<!-- /automd -->\n+## Core Philosophy\n \n-A collection of to/from adapters that convert between I/O formats and Zod-validated objects. The library is designed with a \"one schema in the middle, many edges around it\" philosophy, providing a schema-centric I/O hub for JavaScript. It is a build-less, ESM-only library using `.mjs` files with JSDoc for type safety.\n+The library operates on two primary primitives: `from(format) -> zod` and\n+`to(format) <- zod`. All transformations are deterministic, using canonical\n+ordering and stable serialization to ensure reproducibility. The system is built\n+on the invariant that for any given data, `to(X, from(X, data))` is\n+approximately equal to the original data, with any lossiness being explicitly\n+declared and tracked.\n \n-### ‚ú® Features\n+## ‚ú® Features\n \n-  * **Schema-Centric:** Uses a single Zod schema as the central contract for all I/O operations.\n-  * **Massive Converter Catalog:** Supports a wide range of formats through optional packs, including Office documents, data analytics formats, config files, and knowledge graphs.\n-  * **Symmetric API:** Provides a simple and symmetrical API with three core functions: `parseFrom`, `formatTo`, and `convert`.\n-  * **Deterministic Outputs:** Enforces deterministic I/O with stable key ordering and consistent formatting policies for dates and numbers.\n-  * **Buildless by Design:** Uses `.mjs` and JSDoc to ensure a build-free, portable runtime that works in Node, Deno, and edge environments.\n-  * **Optional AI Adapters:** Can leverage the Vercel AI SDK and Ollama to normalize \"messy\" formats like Office documents into a structured schema.\n-  * **First-Class RDF/Turtle Support:** Treats Turtle as a universal Intermediate Representation (IR), unlocking capabilities for knowledge-driven automation, governance, and provenance.\n-  * **Monorepo Structure:** Organized as a pnpm workspace with a small core library and optional packs for different format categories.\n+- **Zod at the Center**: Your Zod schema is the canonical model; all I/O is\n+  validated against it\n+- **Deterministic I/O**: Transformations are designed to be reproducible with\n+  canonical ordering and stable serialization\n+- **First-Class Provenance**: Automatically capture the source, transform chain,\n+  and checksums for any operation\n+- **Content Addressing**: Artifacts can be keyed by a hash of their schema,\n+  options, and content for verifiable storage\n+- **Streaming First**: The API is designed around async iterable decoders and\n+  encoders to handle large payloads efficiently\n+- **Integrated Validation & Repair**: Parsing and validation occur in a single\n+  pass, with an optional repair loop to auto-fix and re-validate data\n+- **Partial Parsing**: Selectively extract a subset of data by projecting a\n+  partial Zod schema\n+- **Composable Pipeline**: Adapters are designed as composable functors,\n+  allowing for pipelines like `from(A) |> map |> to(B)`\n+- **Schema Versioning**: Includes support for typed transforms to migrate\n+  schemas from vN to vN+1\n+- **Typed Error Model**: Errors are explicitly typed as DecodeError,\n+  ValidateError, or LossyWarning\n+- **Security by Design**: Features safe parsers, resource caps, sandboxable\n+  runners, and deterministic timeouts for untrusted inputs\n+- **Governance & Observability**: Produces exportable audit logs (JSONL, Turtle)\n+  and provides per-stage timings and anomaly flags\n \n-### üöÄ Quick Start\n+## üöÄ Quick Start\n \n-**1. Installation**\n+The programmatic core is pure ESM, with side effects isolated in adapters.\n \n-```bash\n-# Install the core library and zod\n-npm i zod-to-from zod\n+### Programmatic API\n \n-# Install optional packs as needed\n-npm i ztf-pack-office ztf-pack-data ztf-pack-graph\n-```\n-\n-**2. Usage**\n-\n ```javascript\n+// Two primitives: parseFrom() and formatTo()\n+import { parseFrom, formatTo, convert } from 'zod-to-from';\n import { z } from 'zod';\n-import { convert, parseFrom, formatTo } from 'zod-to-from';\n \n-// 1) Define your Zod schema\n-const Config = z.object({\n-  host: z.string(),\n-  port: z.number().int().positive(),\n-  debug: z.boolean().default(false)\n+// Define your schema\n+const UserSchema = z.object({\n+  name: z.string(),\n+  age: z.number(),\n+  active: z.boolean().default(true),\n });\n \n-// 2) Parse from a format (e.g., YAML) into a validated object\n-const obj = await parseFrom(Config, 'yaml', `\n-host: api.example.com\n-port: 8443\n-debug: true\n-`);\n+// Parse and validate in one pass\n+const userObject = await parseFrom(\n+  UserSchema,\n+  'json',\n+  '{\"name\":\"Alice\",\"age\":30}'\n+);\n \n-// 3) Format the object into another format (e.g., TOML)\n-const toml = await formatTo(Config, 'toml', obj);\n+// Format a validated object to another format\n+const userYaml = await formatTo(UserSchema, 'yaml', userObject);\n \n-// 4) Convert between formats in a single step\n-const toml2 = await convert(Config, { from: 'yaml', to: 'toml' }, `\n-host: api.example.com\n-port: 8443\n-`);\n+// Convert between formats\n+const userCsv = await convert(\n+  UserSchema,\n+  { from: 'json', to: 'csv' },\n+  '{\"name\":\"Alice\",\"age\":30}'\n+);\n ```\n \n-### üì¶ API\n+### CLI\n \n-  * `parseFrom(schema, format, input, opts?)`: Parses input from a specified format into a Zod-validated object.\n-  * `formatTo(schema, format, data, opts?)`: Formats a validated object into the specified output format.\n-  * `convert(schema, { from, to }, input, opts?)`: A one-shot function to convert from an input format to an output format.\n-  * `registerAdapter(name, adapter)`: Allows for adding custom format converters at runtime.\n-  * `listAdapters()`: Returns a list of available adapters.\n+ZTF provides a simple noun-verb command-line interface.\n \n-### üìö Converter Packs (The 80/20 \"Dark Matter\")\n+```bash\n+# Convert a source file from one format to another through a schema\n+ztf convert --from json --to yaml --schema ./schemas/user.mjs#UserSchema --in input.json --out output.yaml\n \n-ZTF covers the \"dark matter\" of heterogeneous I/O formats through a series of optional packs.\n+# Parse a file with schema validation\n+ztf parse --schema ./schemas/config.mjs#Config --from yaml --in config.yaml --out config.json\n \n-| Pack | Formats | Shape |\n-| --- | --- | --- |\n-| **Office & Exec Outputs** | `docx-table`, `pptx-slides`, `xlsx`, `pdf-table`, `md`, `html`, `csv` | doc, table |\n-| **Data & Analytics** | `json`, `ndjson`, `parquet`, `arrow`, `avro`, `protobuf`, `sqlite` | tree, records, table |\n-| **Graph & Knowledge** | `ttl`, `nq`, `jsonld`, `plantuml`, `mermaid`, `openapi`, `jsonschema` | graph, diagram |\n-| **DevOps & Config** | `yaml`, `toml`, `ini`, `env`, `dockerfile`, `compose`, `k8s` | tree, records |\n-| **Nunjucks** | `njk`, `md`, `html`, `puml`, `ttl`, `frontmatter` (parse) | doc |\n-| **Communications** | `ics`, `vcard`, `eml`, `msgpack`, `har`, `curl` | calendar, contact, message |\n-| **Media & Meta** | `exif`, `id3`, `base64`, `zip`, `tar`, `pdf-text` | tree, blob, doc |\n-| **Geo & Time** | `geojson`, `topojson`, `kml`, `gpx`, `wkt` | tree |\n+# Format data to a specific format\n+ztf format --schema ./schemas/data.mjs#DataSchema --to csv --in data.json --out data.csv\n \n-### ü§ñ AI-Assisted Adapters\n+# List available adapters\n+ztf list\n+```\n \n-For \"messy\" formats with implicit structure, ZTF provides optional AI-powered adapters.\n+## üì¶ Supported Formats (The 80/20)\n \n-  * **`office-ai` Pack:** Uses the Vercel AI SDK and Ollama to parse formats like `.docx`, `.pptx`, and `.xlsx` by extracting their content and normalizing it into a target Zod schema.\n-  * **Ingestion Only:** This AI-powered normalization is used only for `parseFrom` operations. The `formatTo` operation for creating documents remains deterministic.\n-  * **Provenance:** Outputs from AI adapters are tagged with metadata, such as the LLM model used, for auditability.\n+ZTF prioritizes broad coverage of high-value \"dark matter\" formats before\n+tackling the long tail.\n \n-### üîß CLI (Optional)\n+### Text Formats\n \n-ZTF includes an optional CLI for command-line conversions.\n+- **JSON**, **JSONL/NDJSON**, **YAML**, **TOML**, **CSV/TSV**, **INI**\n \n-```bash\n-# Parse a YAML file into a JSON object\n-npx ztf parse --schema ./schemas/config.mjs#Config --from yaml --in config.yaml --out config.json\n+### Binary Formats\n \n-# Format a JSON object into a TOML file\n-npx ztf format --schema ./schemas/config.mjs#Config --to toml --in config.json --out config.toml\n+- **Parquet**, **Arrow IPC**, **Avro**, **Protobuf**, **MessagePack**, **CBOR**,\n+  **Ion**\n \n-# Convert a CSV file directly to an XLSX spreadsheet\n-npx ztf convert --schema ./schemas/report.mjs#Report[] --from csv --to xlsx --in data.csv --out out.xlsx\n+### Web & API Schemas\n+\n+- **OpenAPI/Swagger** ‚Üî Zod\n+- **JSON Schema** ‚Üî Zod\n+- **GraphQL SDL** ‚Üî Zod\n+\n+### Database & ORM Mappings\n+\n+- **SQL DDL** ‚Üî Zod\n+- **Prisma**, **Drizzle**, **TypeORM**, **Mongoose** mappings\n+\n+### Search & Index Schemas\n+\n+- **Elasticsearch** mappings ‚Üî Zod\n+- **Meilisearch** & **Algolia** shapes\n+\n+### Files & Office Documents (LLM-Assisted)\n+\n+- **PDF**, **Docx**, **XLSX**, and **HTML** can be parsed into Zod objects using\n+  Vercel AI SDK guardrails\n+\n+### Knowledge & Graph Layer\n+\n+- **Turtle/N3** ‚Üî Zod\n+- **RDF triples** ‚Üî Zod records\n+- **SHACL** ‚Üî Zod constraints\n+\n+### Diagrams\n+\n+- **PlantUML** structural views (e.g., class diagrams) ‚Üî Zod projections\n+\n+## üèóÔ∏è Architecture\n+\n+ZTF follows a monolithic structure with clear separation of concerns:\n+\n ```\n+src/\n+‚îú‚îÄ‚îÄ core/                    # Core API and registry\n+‚îÇ   ‚îú‚îÄ‚îÄ registry.mjs        # Adapter registry and utilities\n+‚îÇ   ‚îî‚îÄ‚îÄ main.mjs           # Main API functions (parseFrom, formatTo, convert)\n+‚îú‚îÄ‚îÄ adapters/               # Format converters\n+‚îÇ   ‚îú‚îÄ‚îÄ json.mjs           # JSON adapter\n+‚îÇ   ‚îú‚îÄ‚îÄ yaml.mjs           # YAML adapter\n+‚îÇ   ‚îú‚îÄ‚îÄ csv.mjs            # CSV adapter\n+‚îÇ   ‚îú‚îÄ‚îÄ data.mjs           # Data analytics formats\n+‚îÇ   ‚îú‚îÄ‚îÄ office.mjs         # Office document formats\n+‚îÇ   ‚îú‚îÄ‚îÄ graph.mjs          # Knowledge graph formats\n+‚îÇ   ‚îî‚îÄ‚îÄ nunjucks.mjs       # Template rendering\n+‚îú‚îÄ‚îÄ mappers/                # Schema bridges\n+‚îÇ   ‚îú‚îÄ‚îÄ workflow.mjs       # Workflow-specific mappings\n+‚îÇ   ‚îî‚îÄ‚îÄ kpi.mjs            # KPI-specific mappings\n+‚îú‚îÄ‚îÄ cli/                    # Command-line interface\n+‚îÇ   ‚îú‚îÄ‚îÄ cli.mjs            # Main CLI entry point\n+‚îÇ   ‚îî‚îÄ‚îÄ commands/          # Individual command implementations\n+‚îî‚îÄ‚îÄ index.mjs              # Main library entry point\n+```\n \n-## Usage\n+## üõ°Ô∏è Security and Governance\n \n-Install the package:\n+- **Safe Execution**: Adapters are designed with safe parsers and can be run in\n+  sandboxed environments with deterministic timeouts and size limits for\n+  untrusted inputs\n+- **Typed Configuration**: All configuration, including for adapters, is handled\n+  via Zod schemas to prevent untyped options\n+- **Auditability**: Governance audit logs are exportable as JSONL or Turtle,\n+  making them ready for board-level reporting\n+- **Stability**: Adapters follow strict semantic versioning, and schemas can be\n+  frozen per tag to ensure stability\n \n-```sh\n-# ‚ú® Auto-detect (supports npm, yarn, pnpm, deno and bun)\n-npx nypm install zod-to-from\n+## üõ†Ô∏è Extensibility\n+\n+ZTF is designed to be extensible from the ground up. An adapter kit provides\n+scaffolds, conformance tests, and fixtures to help you quickly add support for\n+new formats.\n+\n+### Creating Custom Adapters\n+\n+```javascript\n+import { registerAdapter } from 'zod-to-from';\n+\n+const customAdapter = {\n+  async parse(input, opts = {}) {\n+    // Parse input to data\n+    const data = parseCustomFormat(input);\n+    return {\n+      data,\n+      metadata: {\n+        format: 'custom',\n+        inputSize: input.length,\n+        ...opts,\n+      },\n+    };\n+  },\n+\n+  async format(data, opts = {}) {\n+    // Format data to string\n+    const output = formatCustomFormat(data);\n+    return {\n+      data: output,\n+      metadata: {\n+        format: 'custom',\n+        outputSize: output.length,\n+        ...opts,\n+      },\n+    };\n+  },\n+\n+  supportsStreaming: false,\n+  isAI: false,\n+  version: '1.0.0',\n+};\n+\n+registerAdapter('custom', customAdapter);\n ```\n \n-Import:\n+## üìã API Reference\n \n-<!-- automd:jsimport cdn name=\"zod-to-from\" -->\n+### Core Functions\n \n-**ESM** (Node.js, Bun, Deno)\n+#### `parseFrom(schema, format, input, options?)`\n \n-```js\n-import { parseFrom, formatTo, convert } from \"zod-to-from\";\n+Parse input from a specified format into a Zod-validated object.\n+\n+#### `formatTo(schema, format, data, options?)`\n+\n+Format a Zod-validated object to a specified output format.\n+\n+#### `convert(schema, conversion, input, options?)`\n+\n+Convert data from one format to another with schema validation.\n+\n+#### `registerAdapter(name, adapter)`\n+\n+Register a new adapter for a specific format.\n+\n+#### `listAdapters()`\n+\n+List all registered adapter names.\n+\n+### Options\n+\n+```typescript\n+interface ZTFOptions {\n+  adapter?: Record<string, unknown>; // Custom options for the specific adapter\n+  validate?: boolean; // Whether to validate the output against the schema\n+  includeProvenance?: boolean; // Whether to include provenance metadata in result\n+  deterministic?: boolean; // Whether to enforce deterministic output\n+  streaming?: boolean; // Whether to use streaming for large datasets\n+}\n ```\n \n-**CDN** (Deno, Bun and Browsers)\n+## üß™ Testing\n \n-```js\n-import { parseFrom, formatTo, convert } from \"https://esm.sh/zod-to-from\";\n+```bash\n+# Run tests\n+pnpm test\n+\n+# Run tests with coverage\n+pnpm test --coverage\n+\n+# Run linting\n+pnpm lint\n+\n+# Fix linting issues\n+pnpm lint:fix\n ```\n \n-<!-- /automd -->\n+### ü§ñ AI Adapter Testing\n \n-## Development\n+The AI adapters include comprehensive tests that verify integration with Ollama\n+models. These tests are **opt-in only** to keep the regular test suite fast:\n \n-<details>\n+```bash\n+# Run AI adapter tests (requires Ollama running locally)\n+pnpm test:ai\n \n-<summary>local development</summary>\n+# Run AI adapter tests in watch mode\n+pnpm test:ai:watch\n \n-- Clone this repository\n-- Install latest LTS version of [Node.js](https://nodejs.org/en/)\n-- Enable [Corepack](https://github.com/nodejs/corepack) using `corepack enable`\n-- Install dependencies using `pnpm install`\n-- Run interactive tests using `pnpm dev`\n+# Run regular tests (AI tests are skipped by default)\n+pnpm test\n+```\n \n-</details>\n+**Prerequisites for AI tests:**\n \n-## License\n+- Ollama installed and running locally\n+- At least one model available (e.g., `qwen3-coder`, `qwen3:8b`)\n+- Test files available in\n+  `node_modules/.pnpm/mammoth@*/node_modules/mammoth/test/test-data/`\n \n-<!-- automd:contributors license=MIT -->\n+The AI tests verify:\n \n-Published under the [MIT](https://github.com/unjs/zod-to-from/blob/main/LICENSE) license.\n-Made by [community](https://github.com/unjs/zod-to-from/graphs/contributors) üíõ\n-<br><br>\n-<a href=\"https://github.com/unjs/zod-to-from/graphs/contributors\">\n-<img src=\"https://contrib.rocks/image?repo=unjs/zod-to-from\" />\n-</a>\n+- ‚úÖ Real document processing (DOCX files)\n+- ‚úÖ Multiple model support\n+- ‚úÖ Custom prompt handling\n+- ‚úÖ Schema validation\n+- ‚úÖ Error handling\n \n-<!-- /automd -->\n+## üìÑ License\n \n-<!-- automd:with-automd -->\n+MIT License - see [LICENSE](LICENSE) for details.\n \n+## ü§ù Contributing\n+\n+Contributions are welcome! Please read our contributing guidelines and submit\n+pull requests to our repository.\n+\n+## üìö Documentation\n+\n+- [API Reference](./docs/api.md)\n+- [Adapter Development Guide](./docs/adapters.md)\n+- [CLI Usage Guide](./docs/cli.md)\n+- [Security Best Practices](./docs/security.md)\n+\n ---\n \n-_ü§ñ auto updated with [automd](https://automd.unjs.io)_\n-\n-<!-- /automd -->\n+**zod-to-from** - Making Zod the universal intermediate representation for all\n+application I/O.\n"
                }
            ],
            "date": 1758642289491,
            "name": "Commit-0",
            "content": "# zod-to-from\n\n<!-- automd:badges color=yellow -->\n\n[![npm version](https://img.shields.io/npm/v/zod-to-from?color=yellow)](https://npmjs.com/package/zod-to-from)\n[![npm downloads](https://img.shields.io/npm/dm/zod-to-from?color=yellow)](https://npm.chart.dev/zod-to-from)\n\n<!-- /automd -->\n\nA collection of to/from adapters that convert between I/O formats and Zod-validated objects. The library is designed with a \"one schema in the middle, many edges around it\" philosophy, providing a schema-centric I/O hub for JavaScript. It is a build-less, ESM-only library using `.mjs` files with JSDoc for type safety.\n\n### ‚ú® Features\n\n  * **Schema-Centric:** Uses a single Zod schema as the central contract for all I/O operations.\n  * **Massive Converter Catalog:** Supports a wide range of formats through optional packs, including Office documents, data analytics formats, config files, and knowledge graphs.\n  * **Symmetric API:** Provides a simple and symmetrical API with three core functions: `parseFrom`, `formatTo`, and `convert`.\n  * **Deterministic Outputs:** Enforces deterministic I/O with stable key ordering and consistent formatting policies for dates and numbers.\n  * **Buildless by Design:** Uses `.mjs` and JSDoc to ensure a build-free, portable runtime that works in Node, Deno, and edge environments.\n  * **Optional AI Adapters:** Can leverage the Vercel AI SDK and Ollama to normalize \"messy\" formats like Office documents into a structured schema.\n  * **First-Class RDF/Turtle Support:** Treats Turtle as a universal Intermediate Representation (IR), unlocking capabilities for knowledge-driven automation, governance, and provenance.\n  * **Monorepo Structure:** Organized as a pnpm workspace with a small core library and optional packs for different format categories.\n\n### üöÄ Quick Start\n\n**1. Installation**\n\n```bash\n# Install the core library and zod\nnpm i zod-to-from zod\n\n# Install optional packs as needed\nnpm i ztf-pack-office ztf-pack-data ztf-pack-graph\n```\n\n**2. Usage**\n\n```javascript\nimport { z } from 'zod';\nimport { convert, parseFrom, formatTo } from 'zod-to-from';\n\n// 1) Define your Zod schema\nconst Config = z.object({\n  host: z.string(),\n  port: z.number().int().positive(),\n  debug: z.boolean().default(false)\n});\n\n// 2) Parse from a format (e.g., YAML) into a validated object\nconst obj = await parseFrom(Config, 'yaml', `\nhost: api.example.com\nport: 8443\ndebug: true\n`);\n\n// 3) Format the object into another format (e.g., TOML)\nconst toml = await formatTo(Config, 'toml', obj);\n\n// 4) Convert between formats in a single step\nconst toml2 = await convert(Config, { from: 'yaml', to: 'toml' }, `\nhost: api.example.com\nport: 8443\n`);\n```\n\n### üì¶ API\n\n  * `parseFrom(schema, format, input, opts?)`: Parses input from a specified format into a Zod-validated object.\n  * `formatTo(schema, format, data, opts?)`: Formats a validated object into the specified output format.\n  * `convert(schema, { from, to }, input, opts?)`: A one-shot function to convert from an input format to an output format.\n  * `registerAdapter(name, adapter)`: Allows for adding custom format converters at runtime.\n  * `listAdapters()`: Returns a list of available adapters.\n\n### üìö Converter Packs (The 80/20 \"Dark Matter\")\n\nZTF covers the \"dark matter\" of heterogeneous I/O formats through a series of optional packs.\n\n| Pack | Formats | Shape |\n| --- | --- | --- |\n| **Office & Exec Outputs** | `docx-table`, `pptx-slides`, `xlsx`, `pdf-table`, `md`, `html`, `csv` | doc, table |\n| **Data & Analytics** | `json`, `ndjson`, `parquet`, `arrow`, `avro`, `protobuf`, `sqlite` | tree, records, table |\n| **Graph & Knowledge** | `ttl`, `nq`, `jsonld`, `plantuml`, `mermaid`, `openapi`, `jsonschema` | graph, diagram |\n| **DevOps & Config** | `yaml`, `toml`, `ini`, `env`, `dockerfile`, `compose`, `k8s` | tree, records |\n| **Nunjucks** | `njk`, `md`, `html`, `puml`, `ttl`, `frontmatter` (parse) | doc |\n| **Communications** | `ics`, `vcard`, `eml`, `msgpack`, `har`, `curl` | calendar, contact, message |\n| **Media & Meta** | `exif`, `id3`, `base64`, `zip`, `tar`, `pdf-text` | tree, blob, doc |\n| **Geo & Time** | `geojson`, `topojson`, `kml`, `gpx`, `wkt` | tree |\n\n### ü§ñ AI-Assisted Adapters\n\nFor \"messy\" formats with implicit structure, ZTF provides optional AI-powered adapters.\n\n  * **`office-ai` Pack:** Uses the Vercel AI SDK and Ollama to parse formats like `.docx`, `.pptx`, and `.xlsx` by extracting their content and normalizing it into a target Zod schema.\n  * **Ingestion Only:** This AI-powered normalization is used only for `parseFrom` operations. The `formatTo` operation for creating documents remains deterministic.\n  * **Provenance:** Outputs from AI adapters are tagged with metadata, such as the LLM model used, for auditability.\n\n### üîß CLI (Optional)\n\nZTF includes an optional CLI for command-line conversions.\n\n```bash\n# Parse a YAML file into a JSON object\nnpx ztf parse --schema ./schemas/config.mjs#Config --from yaml --in config.yaml --out config.json\n\n# Format a JSON object into a TOML file\nnpx ztf format --schema ./schemas/config.mjs#Config --to toml --in config.json --out config.toml\n\n# Convert a CSV file directly to an XLSX spreadsheet\nnpx ztf convert --schema ./schemas/report.mjs#Report[] --from csv --to xlsx --in data.csv --out out.xlsx\n```\n\n## Usage\n\nInstall the package:\n\n```sh\n# ‚ú® Auto-detect (supports npm, yarn, pnpm, deno and bun)\nnpx nypm install zod-to-from\n```\n\nImport:\n\n<!-- automd:jsimport cdn name=\"zod-to-from\" -->\n\n**ESM** (Node.js, Bun, Deno)\n\n```js\nimport { parseFrom, formatTo, convert } from \"zod-to-from\";\n```\n\n**CDN** (Deno, Bun and Browsers)\n\n```js\nimport { parseFrom, formatTo, convert } from \"https://esm.sh/zod-to-from\";\n```\n\n<!-- /automd -->\n\n## Development\n\n<details>\n\n<summary>local development</summary>\n\n- Clone this repository\n- Install latest LTS version of [Node.js](https://nodejs.org/en/)\n- Enable [Corepack](https://github.com/nodejs/corepack) using `corepack enable`\n- Install dependencies using `pnpm install`\n- Run interactive tests using `pnpm dev`\n\n</details>\n\n## License\n\n<!-- automd:contributors license=MIT -->\n\nPublished under the [MIT](https://github.com/unjs/zod-to-from/blob/main/LICENSE) license.\nMade by [community](https://github.com/unjs/zod-to-from/graphs/contributors) üíõ\n<br><br>\n<a href=\"https://github.com/unjs/zod-to-from/graphs/contributors\">\n<img src=\"https://contrib.rocks/image?repo=unjs/zod-to-from\" />\n</a>\n\n<!-- /automd -->\n\n<!-- automd:with-automd -->\n\n---\n\n_ü§ñ auto updated with [automd](https://automd.unjs.io)_\n\n<!-- /automd -->\n"
        }
    ]
}